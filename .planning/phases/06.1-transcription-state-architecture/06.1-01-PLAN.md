---
phase: 06.1-transcription-state-architecture
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/contexts/TranscriptionContext.tsx
  - src/services/storageService.types.ts
  - src/services/storageService.ts
  - src/app/App.tsx
  - package.json
  - package-lock.json
autonomous: true

must_haves:
  truths:
    - 'TranscriptionProvider wraps BrowserRouter in App.tsx, survives all route navigation'
    - 'Split contexts exist: useTranscriptionState() and useTranscriptionActions() are importable'
    - 'The interrupted ProjectStatus is recognized by storage validators'
    - 'sonner is installed and Toaster component is rendered inside BrowserRouter'
    - 'Projects left in uploading/processing status on reload are detected as interrupted'
  artifacts:
    - path: 'src/contexts/TranscriptionContext.tsx'
      provides: 'TranscriptionProvider, useTranscriptionState, useTranscriptionActions'
      exports:
        [
          'TranscriptionProvider',
          'useTranscriptionState',
          'useTranscriptionActions',
        ]
    - path: 'src/services/storageService.types.ts'
      provides: "'interrupted' in ProjectStatus union"
      contains: 'interrupted'
    - path: 'src/app/App.tsx'
      provides: 'Provider nesting with TranscriptionProvider'
      contains: 'TranscriptionProvider'
  key_links:
    - from: 'src/contexts/TranscriptionContext.tsx'
      to: 'src/contexts/ProjectsContext.tsx'
      via: 'useProjects() for interrupt detection and project status updates'
      pattern: 'useProjects'
    - from: 'src/app/App.tsx'
      to: 'src/contexts/TranscriptionContext.tsx'
      via: 'TranscriptionProvider wrapper'
      pattern: 'TranscriptionProvider'
---

<objective>
Create the TranscriptionContext provider that lifts the transcription state machine out of component-local scope into a root-level context that survives route navigation. Add the `interrupted` ProjectStatus, install sonner for toasts, and wire the provider into App.tsx.

Purpose: This is the foundational change for Phase 06.1. The current useTranscription hook uses useReducer inside ProjectPage -- navigating away destroys the state machine, abort controller, and accumulated segments. Moving all of this into a context provider above the router fixes the core bug.

Output: TranscriptionContext.tsx with split state/actions contexts, updated storageService types, sonner installed, App.tsx rewired.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-transcription-state-architecture/06.1-CONTEXT.md
@.planning/phases/06.1-transcription-state-architecture/06.1-RESEARCH.md
@src/features/project/hooks/useTranscription.ts
@src/contexts/SettingsContext.tsx
@src/contexts/ProjectsContext.tsx
@src/app/App.tsx
@src/services/storageService.types.ts
@src/services/storageService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install sonner, add interrupted status, create TranscriptionContext</name>
  <files>
    package.json
    package-lock.json
    src/services/storageService.types.ts
    src/services/storageService.ts
    src/contexts/TranscriptionContext.tsx
  </files>
  <action>
**Step 1: Install sonner**

Run `npm install sonner@2.0.7` (pin exact version per project convention).

**Step 2: Add 'interrupted' to ProjectStatus**

In `src/services/storageService.types.ts`:

- Add `| 'interrupted'` to the `ProjectStatus` union type (after `'cancelled'`)

In `src/services/storageService.ts`:

- Add `'interrupted'` to the `VALID_PROJECT_STATUSES` Set

No schema migration needed -- `interrupted` is only set at runtime by the provider, never as an initial persisted status.

**Step 3: Create TranscriptionContext.tsx**

Create `src/contexts/TranscriptionContext.tsx` following the exact SettingsContext/ProjectsContext pattern (useReducer + createContext + Provider). Move ALL state machine logic from `useTranscription.ts`:

1. **Types** -- Copy TranscriptionState, TranscriptionEvent, TranscriptionMachineState from useTranscription.ts. Add:

   ```typescript
   interface TranscriptionContextState extends TranscriptionMachineState {
     activeProjectId: string | null;
     isTranscribing: boolean;
   }

   interface TranscriptionActions {
     startTranscription: (
       file: File,
       mimeType: string,
       duration: number,
       projectId: string
     ) => Promise<void>;
     cancel: () => void;
     reset: () => void;
   }
   ```

2. **TRANSITIONS map** -- Copy exactly from useTranscription.ts (unchanged)

3. **transcriptionReducer** -- Copy exactly from useTranscription.ts (unchanged)

4. **Split contexts** (performance optimization per research):

   ```typescript
   const TranscriptionStateContext = createContext<
     TranscriptionContextState | undefined
   >(undefined);
   const TranscriptionActionsContext = createContext<
     TranscriptionActions | undefined
   >(undefined);
   ```

5. **TranscriptionProvider component:**
   - `useReducer(transcriptionReducer, initialState)` for the state machine
   - `useRef<AbortController | null>(null)` for the abort controller
   - `useState<string | null>(null)` for activeProjectId
   - Import and use `useProjects()` for project status updates and interrupt detection
   - Import `getDecryptedKey` from cryptoService, `uploadFile`/`generateTranscript` from geminiService, `debouncedSaveTranscript`/`flushPendingWrites`/`saveTranscript` from storageService

   **startTranscription callback** (useCallback, deps=[]):
   - Same logic as current useTranscription.ts hook's startTranscription
   - Accept (file, mimeType, duration, projectId)
   - Set activeProjectId before dispatching START
   - Create fresh AbortController, decrypt key, upload, transcribe
   - Track accumulatedSegments locally in closure
   - On PROGRESS: debounced save to localStorage
   - On PROCESSING_COMPLETE: save final transcript, update project status to 'completed' via updateProject, clear activeProjectId
   - On AbortError: dispatch CANCELLED, flush writes, update project status to 'cancelled' via updateProject
   - On other error: dispatch ERROR, update project status to 'error' via updateProject

   **cancel callback** (useCallback, deps=[]):
   - Same as current: dispatch CANCEL then abort()

   **reset callback** (useCallback, deps=[]):
   - dispatch RESET, clear activeProjectId

   **Interrupt detection useEffect:**
   - Depends on `projectsState.initialized`
   - When initialized and machineState.state === 'idle': scan all projects for status 'uploading' or 'processing'
   - For each found, call `updateProject({...project, status: 'interrupted'})`
   - Guard with eslint-disable for exhaustive deps (run once on init)

   **beforeunload useEffect:**
   - When isTranscribing is true, add beforeunload listener that calls `e.preventDefault()` and `flushPendingWrites()`
   - Cleanup on unmount or when isTranscribing becomes false

   **Derive isTranscribing:**
   `const isTranscribing = ['uploading', 'processing', 'cancelling'].includes(machineState.state);`

   **Memoize context values:**
   - stateValue via useMemo: `{ ...machineState, activeProjectId, isTranscribing }`
   - actionsValue via useMemo: `{ startTranscription, cancel, reset }` (stable refs)

   **Render:**

   ```tsx
   <TranscriptionStateContext.Provider value={stateValue}>
     <TranscriptionActionsContext.Provider value={actionsValue}>
       {children}
     </TranscriptionActionsContext.Provider>
   </TranscriptionStateContext.Provider>
   ```

6. **Consumer hooks:**
   ```typescript
   export function useTranscriptionState(): TranscriptionContextState { ... }
   export function useTranscriptionActions(): TranscriptionActions { ... }
   ```
   Both throw if used outside provider (standard pattern).

**Important: Project lifecycle updates in the provider**

The provider must update project status through the transcription lifecycle (uploading/processing/completed/cancelled/error). This logic currently lives in ProjectPage's useEffect. Move it INTO the startTranscription callback itself:

- After upload completes: `updateProject({...project, status: 'processing'})` -- but the provider doesn't have the full project object. Instead, use a simpler approach: use `projectsState.projects.find(p => p.id === projectId)` inside the callback, or pass the updateProject function.
- Actually, the cleanest approach: the startTranscription callback in the provider handles status updates internally. It has access to useProjects() via the provider component. Update project status to 'uploading' on START, 'processing' on UPLOAD_COMPLETE, 'completed' on PROCESSING_COMPLETE (with saveTranscript), 'cancelled' on AbortError, 'error' on other errors.
- For completion: save transcript with `saveTranscript({ projectId, segments, completedAt: new Date().toISOString() })`, reconcile duration from max timestamp, update project with status 'completed' and segmentCount.

**Do NOT use useBlocker** -- user decision says "Free navigation always."
</action>
<verify> - `npx tsc --noEmit` passes with zero errors - `npx eslint src/contexts/TranscriptionContext.tsx` passes - `npm ls sonner` shows sonner@2.0.7 - `grep -c "interrupted" src/services/storageService.types.ts` returns 1 - `grep -c "interrupted" src/services/storageService.ts` returns 1
</verify>
<done>
TranscriptionContext.tsx exists with TranscriptionProvider, useTranscriptionState, useTranscriptionActions exports. sonner@2.0.7 is installed. 'interrupted' is a valid ProjectStatus. TypeScript compiles cleanly.
</done>
</task>

<task type="auto">
  <name>Task 2: Wire TranscriptionProvider and Toaster into App.tsx</name>
  <files>
    src/app/App.tsx
  </files>
  <action>
Update `src/app/App.tsx` to add TranscriptionProvider and sonner's Toaster.

**Provider nesting order** (per research Pattern 2):

```
SettingsProvider > ProjectsProvider > TranscriptionProvider > BrowserRouter
```

TranscriptionProvider needs ProjectsContext (for updateProject, interrupt detection) so it goes inside ProjectsProvider. BrowserRouter goes inside TranscriptionProvider because route components need transcription state.

**Toaster placement:**
Add `<Toaster position="bottom-right" richColors closeButton />` from sonner INSIDE BrowserRouter (so that toast action click handlers can use router navigation in the TranscriptionWatcher component added in Plan 02).

**Updated App.tsx structure:**

```tsx
import { BrowserRouter, Routes, Route } from 'react-router';
import { Toaster } from 'sonner';
import { SettingsProvider } from '@/contexts/SettingsContext';
import { ProjectsProvider } from '@/contexts/ProjectsContext';
import { TranscriptionProvider } from '@/contexts/TranscriptionContext';
import Layout from './Layout';
import DashboardLayout from '@/features/dashboard/DashboardLayout';
import CenterPanel from '@/features/dashboard/components/CenterPanel';
import SettingsPage from '@/features/settings/SettingsPage';

export default function App() {
  return (
    <SettingsProvider>
      <ProjectsProvider>
        <TranscriptionProvider>
          <BrowserRouter>
            <Toaster position="bottom-right" richColors closeButton />
            <Routes>
              <Route element={<Layout />}>
                <Route element={<DashboardLayout />}>
                  <Route index element={<CenterPanel />} />
                  <Route path="project/:projectId" element={<CenterPanel />} />
                </Route>
                <Route path="settings" element={<SettingsPage />} />
              </Route>
            </Routes>
          </BrowserRouter>
        </TranscriptionProvider>
      </ProjectsProvider>
    </SettingsProvider>
  );
}
```

  </action>
  <verify>
    - `npx tsc --noEmit` passes
    - `npx eslint src/app/App.tsx` passes
    - `npm run build` succeeds (confirms no import resolution issues)
  </verify>
  <done>
    App.tsx has TranscriptionProvider between ProjectsProvider and BrowserRouter. Toaster from sonner is rendered inside BrowserRouter. Build passes cleanly.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` -- full production build succeeds
2. `npx tsc --noEmit` -- zero TypeScript errors
3. `npx eslint src/` -- no new lint errors
4. Manual check: `src/contexts/TranscriptionContext.tsx` exports TranscriptionProvider, useTranscriptionState, useTranscriptionActions
5. Manual check: `src/app/App.tsx` nesting order is SettingsProvider > ProjectsProvider > TranscriptionProvider > BrowserRouter > Toaster
6. Manual check: `src/services/storageService.types.ts` has 'interrupted' in ProjectStatus
7. Manual check: `src/services/storageService.ts` has 'interrupted' in VALID_PROJECT_STATUSES
</verification>

<success_criteria>

- TranscriptionContext exists as a root-level provider with split state/actions contexts
- The state machine (reducer, TRANSITIONS, types) is moved into the context provider
- startTranscription, cancel, reset are exposed via useTranscriptionActions()
- State (machineState, activeProjectId, isTranscribing) exposed via useTranscriptionState()
- Interrupt detection marks orphaned uploading/processing projects as 'interrupted' on mount
- beforeunload shows browser confirmation dialog during active transcription
- sonner installed and Toaster rendered
- Build and type-check pass cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/06.1-transcription-state-architecture/06.1-01-SUMMARY.md`
</output>
