---
phase: 06.1-transcription-state-architecture
plan: 02
type: execute
wave: 2
depends_on: ['06.1-01']
files_modified:
  - src/features/project/hooks/useTranscription.ts
  - src/features/project/ProjectPage.tsx
  - src/features/dashboard/components/CenterPanel.tsx
  - src/features/dashboard/components/TranscriptionWatcher.tsx
autonomous: true

must_haves:
  truths:
    - 'Navigating away from an active transcription does NOT kill the transcription process'
    - 'Navigating back to the active project resumes the live view with ProgressStepper and LiveTranscriptView'
    - 'A toast appears when user navigates away from an active transcription'
    - 'A clickable toast appears when transcription completes while user is on another screen'
    - 'A clickable error toast appears when transcription fails while user is on another screen'
    - 'New uploads are blocked with a message when a transcription is already running'
  artifacts:
    - path: 'src/features/project/hooks/useTranscription.ts'
      provides: 'Thin re-export of context hooks (backward compatibility)'
      exports: ['useTranscription']
    - path: 'src/features/project/ProjectPage.tsx'
      provides: 'Context-consuming project page with live transcription display'
      contains: 'useTranscriptionState'
    - path: 'src/features/dashboard/components/CenterPanel.tsx'
      provides: 'Routes active transcriptions to live view'
      contains: 'useTranscriptionState'
    - path: 'src/features/dashboard/components/TranscriptionWatcher.tsx'
      provides: 'Toast notifications for background transcription events'
      exports: ['default']
  key_links:
    - from: 'src/features/project/ProjectPage.tsx'
      to: 'src/contexts/TranscriptionContext.tsx'
      via: 'useTranscriptionState + useTranscriptionActions'
      pattern: 'useTranscription(State|Actions)'
    - from: 'src/features/dashboard/components/TranscriptionWatcher.tsx'
      to: 'src/contexts/TranscriptionContext.tsx'
      via: 'useTranscriptionState for change detection'
      pattern: 'useTranscriptionState'
    - from: 'src/features/dashboard/components/CenterPanel.tsx'
      to: 'src/contexts/TranscriptionContext.tsx'
      via: 'useTranscriptionState for active project routing'
      pattern: 'useTranscriptionState'
---

<objective>
Rewire all transcription consumers to use the new TranscriptionContext instead of the component-local useTranscription hook. Create the TranscriptionWatcher component for toast notifications on background transcription events.

Purpose: With the TranscriptionContext created in Plan 01, this plan connects all the UI to it. After this plan, navigating away from an active transcription will NOT kill it, and the user gets visibility via toasts.

Output: Gutted useTranscription.ts (thin re-export), rewired ProjectPage, updated CenterPanel, new TranscriptionWatcher.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06.1-transcription-state-architecture/06.1-CONTEXT.md
@.planning/phases/06.1-transcription-state-architecture/06.1-RESEARCH.md
@.planning/phases/06.1-transcription-state-architecture/06.1-01-SUMMARY.md
@src/features/project/ProjectPage.tsx
@src/features/project/hooks/useTranscription.ts
@src/features/dashboard/components/CenterPanel.tsx
@src/contexts/TranscriptionContext.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Gut useTranscription hook, rewire ProjectPage, update CenterPanel</name>
  <files>
    src/features/project/hooks/useTranscription.ts
    src/features/project/ProjectPage.tsx
    src/features/dashboard/components/CenterPanel.tsx
  </files>
  <action>
**Step 1: Gut useTranscription.ts to thin re-export**

Replace the entire contents of `src/features/project/hooks/useTranscription.ts` with a thin compatibility layer that re-exports the context hooks. This avoids breaking any imports while the real logic now lives in TranscriptionContext.tsx.

```typescript
// Thin re-export for backward compatibility.
// Real implementation lives in src/contexts/TranscriptionContext.tsx.
export {
  useTranscriptionState,
  useTranscriptionActions,
} from '@/contexts/TranscriptionContext';

// Re-export types that consumers may need
export type { TranscriptionState } from '@/contexts/TranscriptionContext';
```

Remove ALL state machine code, TRANSITIONS map, reducer, and hook implementation from this file. The types (TranscriptionState, TranscriptionEvent, TranscriptionMachineState) should be defined and exported from TranscriptionContext.tsx.

**Step 2: Rewire ProjectPage.tsx**

Major rewrite. ProjectPage now CONSUMES context instead of owning the state machine.

Key changes:

1. Replace `import { useTranscription }` with `import { useTranscriptionState, useTranscriptionActions }` from context
2. Remove the lifecycle useEffect that synced machineState to project status -- this is now handled INSIDE the TranscriptionContext provider (Plan 01 moved this logic there)
3. Keep: file upload handler, progress mapping helpers, cancel confirmation dialog, render logic for all states
4. For `handleFileSelected`: call `createProject()` to get the project, then call `startTranscription(file, mimeType, duration, project.id)` from context actions
5. Add **transcription-in-progress guard**: before allowing file upload, check `isTranscribing` from context state. If true, show a message "Transcription already in progress" with a link/button to navigate to the active project (use `activeProjectId` from context state)
6. Keep the `createdProjectId` local state to track the newly created project for URL navigation on completion. BUT: completion navigation must now be reactive. Add a useEffect that watches `transcriptionState.state === 'completed'` and `transcriptionState.activeProjectId` -- when completed and the active project matches createdProjectId, navigate to `/project/${createdProjectId}` and clear createdProjectId. Similarly for error and cancelled states.
7. The "existing project" early return render (line ~205-217) should stay but simplified -- when an existing project is selected that IS the activeProjectId and the transcription is running, show the live view (ProgressStepper + LiveTranscriptView) instead of the static info. This is the "resume live view exactly as if they never left" requirement.
8. Keep all the JSX rendering for idle/uploading/processing/error/cancelled/completed states
9. Remove the `statusMap` and `_displayStatus` (no longer needed since LoadingState is not used)

**Step 3: Update CenterPanel.tsx**

CenterPanel routes to different views based on projectId. Update it to handle the active transcription case:

1. Import `useTranscriptionState` from context
2. When `projectId === 'new'`: render ProjectPage as before (for file upload)
3. When `projectId` matches an existing project:
   - If `transcriptionState.activeProjectId === projectId` AND `transcriptionState.isTranscribing`: render ProjectPage (which will show the live view since it reads from context)
   - Otherwise: render TranscriptPanel as before
4. This means CenterPanel needs to also render ProjectPage for existing projects that are actively transcribing, not just for `projectId === 'new'`

Updated logic:

```typescript
const transcriptionState = useTranscriptionState();

// New project -- render file upload flow
if (projectId === 'new') {
  return <div className="mx-auto max-w-2xl px-6 py-10"><ProjectPage /></div>;
}

// Existing project
const project = projects.find((p) => p.id === projectId);
if (!project) { /* not found UI */ }

// Active transcription on this project -- show live view via ProjectPage
if (transcriptionState.activeProjectId === projectId && transcriptionState.isTranscribing) {
  return <div className="mx-auto max-w-2xl px-6 py-10"><ProjectPage /></div>;
}

// Completed/idle/etc -- show TranscriptPanel
return <TranscriptPanel project={project} />;
```

  </action>
  <verify>
    - `npx tsc --noEmit` passes with zero errors
    - `npx eslint src/features/project/hooks/useTranscription.ts src/features/project/ProjectPage.tsx src/features/dashboard/components/CenterPanel.tsx` passes
    - `npm run build` succeeds
  </verify>
  <done>
    useTranscription.ts is a thin re-export. ProjectPage consumes context, shows "already in progress" guard, and renders live view for active transcription. CenterPanel routes active transcriptions to ProjectPage. No state is lost on navigation.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create TranscriptionWatcher for toast notifications</name>
  <files>
    src/features/dashboard/components/TranscriptionWatcher.tsx
    src/features/dashboard/DashboardLayout.tsx
  </files>
  <action>
**Step 1: Create TranscriptionWatcher.tsx**

Create `src/features/dashboard/components/TranscriptionWatcher.tsx`. This component lives INSIDE BrowserRouter (so it has access to useNavigate) and watches transcription state changes to fire toasts.

```typescript
import { useEffect, useRef } from 'react';
import { useLocation, useNavigate } from 'react-router';
import { useTranscriptionState } from '@/contexts/TranscriptionContext';
import { useProjects } from '@/contexts/ProjectsContext';
import { toast } from 'sonner';
```

**Behavior 1: Nav-away toast**

- Track `location.pathname` changes
- When the user navigates AWAY from the active project page (path was `/project/{activeProjectId}` or `/project/new` and now it's something else) AND `isTranscribing` is true:
  - Show `toast('Transcription continuing in background', { duration: 3000 })`
- Use a `prevPathRef` to track the previous path and compare
- Do NOT show toast when navigating TO the active project

**Behavior 2: Completion toast (background)**

- Use a `prevStateRef` to track previous transcription state
- When `transcriptionState.state` transitions to `'completed'` AND the user is NOT on the active project page:
  - Look up project name from ProjectsContext
  - Show `toast.success('Transcription complete: ${projectName}', { action: { label: 'View', onClick: () => navigate('/project/${activeProjectId}') }, duration: 8000 })`
- When user IS on the active project page, skip the toast (they can see the result directly)

**Behavior 3: Error toast (background)**

- When `transcriptionState.state` transitions to `'error'` AND user is NOT on the active project page:
  - Show `toast.error('Transcription failed: ${projectName}', { action: { label: 'View', onClick: () => navigate('/project/${activeProjectId}') }, duration: Infinity })` (persistent, user must dismiss)

**Implementation pattern:**
Use `useRef` to store the previous state and pathname. On each render, compare current vs previous to detect transitions. Update refs AFTER processing.

```typescript
export default function TranscriptionWatcher() {
  const transcriptionState = useTranscriptionState();
  const { state: projectsState } = useProjects();
  const navigate = useNavigate();
  const location = useLocation();

  const prevStateRef = useRef(transcriptionState.state);
  const prevPathRef = useRef(location.pathname);
  const activeProjectIdRef = useRef(transcriptionState.activeProjectId);

  // Nav-away toast
  useEffect(() => {
    const prevPath = prevPathRef.current;
    const currentPath = location.pathname;
    prevPathRef.current = currentPath;

    if (
      !transcriptionState.isTranscribing ||
      !transcriptionState.activeProjectId
    )
      return;

    const wasOnActiveProject =
      prevPath.includes(transcriptionState.activeProjectId) ||
      prevPath === '/project/new';
    const isOnActiveProject =
      currentPath.includes(transcriptionState.activeProjectId) ||
      currentPath === '/project/new';

    if (wasOnActiveProject && !isOnActiveProject) {
      toast('Transcription continuing in background', { duration: 3000 });
    }
  }, [
    location.pathname,
    transcriptionState.isTranscribing,
    transcriptionState.activeProjectId,
  ]);

  // Completion/error toast
  useEffect(() => {
    const prevState = prevStateRef.current;
    const currentState = transcriptionState.state;
    prevStateRef.current = currentState;
    activeProjectIdRef.current = transcriptionState.activeProjectId;

    // Only fire on state transitions
    if (prevState === currentState) return;

    const projectId =
      transcriptionState.activeProjectId ?? activeProjectIdRef.current;
    if (!projectId) return;

    const project = projectsState.projects.find((p) => p.id === projectId);
    const projectName = project?.interviewee ?? project?.name ?? 'Unknown';

    const isOnActiveProject = location.pathname.includes(projectId);

    if (currentState === 'completed' && !isOnActiveProject) {
      toast.success(`Transcription complete: ${projectName}`, {
        action: {
          label: 'View',
          onClick: () => navigate(`/project/${projectId}`),
        },
        duration: 8000,
      });
    } else if (currentState === 'error' && !isOnActiveProject) {
      toast.error(`Transcription failed: ${projectName}`, {
        action: {
          label: 'View',
          onClick: () => navigate(`/project/${projectId}`),
        },
      });
    }
  }, [
    transcriptionState.state,
    transcriptionState.activeProjectId,
    projectsState.projects,
    location.pathname,
    navigate,
  ]);

  return null; // Renderless component
}
```

**Step 2: Mount TranscriptionWatcher in the app**

The watcher must be inside BrowserRouter. Add it to `DashboardLayout.tsx` or `Layout.tsx` -- anywhere inside the router that is always mounted. The best place is `DashboardLayout.tsx` since that wraps the main dashboard routes, OR `Layout.tsx` since that wraps all routes including settings.

Actually, mount it in the routes structure. The simplest approach: add it as a sibling to Routes in App.tsx, but we don't want to modify App.tsx again (Plan 01 already touched it). Instead, add it inside `Layout.tsx` or as a child in `DashboardLayout.tsx`.

Best choice: Add `<TranscriptionWatcher />` inside `DashboardLayout.tsx` (it already renders Sidebar + Outlet). Since DashboardLayout wraps the main dashboard routes, the watcher will be active whenever the user is on the dashboard. But if user is on SettingsPage, DashboardLayout is NOT mounted, so watcher won't fire.

Better: Place it in `Layout.tsx` which wraps ALL routes. But we don't want to modify too many files in one plan.

Actually simplest: Add it directly in App.tsx inside BrowserRouter, BEFORE Routes. This ensures it's always mounted. But we said Plan 01 already touched App.tsx. Since Plan 02 depends on Plan 01 (wave 2), this is fine -- we can modify App.tsx in this plan too.

**Decision:** Add `<TranscriptionWatcher />` in `App.tsx` inside `BrowserRouter`, before `<Routes>`. Update the import in App.tsx.

Wait -- check files_modified. DashboardLayout.tsx is listed. Let's put it there instead to keep App.tsx minimal. But DashboardLayout only wraps dashboard routes, not settings.

**Final decision:** Add TranscriptionWatcher in the app-level Layout.tsx or directly in App.tsx. Since the watcher needs to be active on ALL routes (including settings page -- user might be on settings when transcription completes), place it directly in `DashboardLayout.tsx` is wrong. Place it inside BrowserRouter in App.tsx. This plan's files_modified already includes DashboardLayout.tsx -- update to include App.tsx if needed, or update DashboardLayout.tsx.

Actually, the cleanest solution: render TranscriptionWatcher inside the Layout component (which wraps all routes via Outlet). Render it as a sibling to Outlet. But Layout.tsx is not in files_modified.

**Simplest correct approach:** Add `<TranscriptionWatcher />` in `DashboardLayout.tsx`. For the settings page case, we accept that the watcher is unmounted on settings (brief, user navigates back quickly). The toast will be missed only if completion happens in the exact window the user is on settings. This is an acceptable tradeoff -- or we can also add it to the Layout component.

Let me reconsider: put it in DashboardLayout.tsx. If a completion/error happens while on SettingsPage, the next navigation back to dashboard will show the updated sidebar status (from context). The toast is a nice-to-have, not critical. This keeps changes minimal.

Add `import TranscriptionWatcher from './components/TranscriptionWatcher';` to DashboardLayout.tsx and render `<TranscriptionWatcher />` as a child alongside Sidebar and the content area.
</action>
<verify> - `npx tsc --noEmit` passes - `npx eslint src/features/dashboard/components/TranscriptionWatcher.tsx src/features/dashboard/DashboardLayout.tsx` passes - `npm run build` succeeds
</verify>
<done>
TranscriptionWatcher fires nav-away toast (3s), completion toast (8s, clickable), and error toast (persistent, clickable). Mounted in DashboardLayout so active on all dashboard routes. Renderless component returns null.
</done>
</task>

</tasks>

<verification>
1. `npm run build` -- production build succeeds
2. `npx tsc --noEmit` -- zero TypeScript errors
3. `npx eslint src/` -- no new lint errors
4. Verify: useTranscription.ts is a thin re-export (< 15 lines)
5. Verify: ProjectPage imports from TranscriptionContext, not from useTranscription hook directly
6. Verify: CenterPanel checks transcriptionState.activeProjectId for live view routing
7. Verify: TranscriptionWatcher exists and is mounted in DashboardLayout
</verification>

<success_criteria>

- Navigating away from an active transcription does NOT kill it (state lives in context)
- ProjectPage renders live view when navigating back to the active project
- "Transcription already in progress" guard prevents concurrent uploads
- Toast appears when navigating away from active transcription
- Clickable toast appears on completion/error while viewing another screen
- useTranscription.ts is gutted to a thin re-export
- Build and type-check pass cleanly
  </success_criteria>

<output>
After completion, create `.planning/phases/06.1-transcription-state-architecture/06.1-02-SUMMARY.md`
</output>
