# Phase 6.1: Transcription State Architecture - Research

**Researched:** 2026-02-08
**Domain:** React Context state lifting, background async operation persistence, toast notifications
**Confidence:** HIGH

<user_constraints>

## User Constraints (from CONTEXT.md)

### Locked Decisions

#### Concurrent transcription

- One transcription at a time -- no parallel runs
- If a transcription is already running, block new uploads with a message like "Transcription already in progress" and link to the active project
- User has never needed parallel runs; the issue is navigating away mid-run, not running multiple

#### Navigation behavior

- Free navigation always -- user can browse any project, settings, etc. while transcription runs
- Transcription process must not depend on which screen is mounted
- Brief toast notification when user navigates away from active transcription ("Transcription continuing in background")
- Cancel button only accessible from the active project's view (navigate back via sidebar to cancel)
- Warn if user tries to change/remove API key in Settings during active transcription (would break the run)
- Settings page otherwise fully accessible during transcription

#### State recovery on reload

- Browser refresh kills the async process -- show partial transcript with a "Resume transcription" button (retry using persisted fileUri if within 48h, re-upload otherwise)
- Manual retry only -- no auto-retry when user views an interrupted project
- Separate statuses for "cancelled by user" vs "interrupted by reload/crash" -- different indicators and different implied actions
- Interrupted projects show a warning indicator (yellow/orange dot) in sidebar -- distinct from the active spinner and from cancelled state

#### Background visibility

- Animated spinner/pulse on the sidebar item for actively transcribing project
- On completion while viewing another screen: sidebar updates + clickable toast ("Interview with [name] -- transcription complete", clicking navigates to project)
- On error while viewing another screen: same pattern -- error toast (clickable) + sidebar error indicator (red/warning icon)
- When user navigates back to the active project: resume live view exactly as if they never left (live transcript, progress stepper, auto-scroll)

### Claude's Discretion

- Tab close behavior during active transcription (browser confirm dialog vs silent flush)
- Toast auto-dismiss timing and animation style
- Exact spinner/pulse animation design for sidebar
- Internal architecture of the TranscriptionContext provider (reducer shape, how to reconnect to orphaned async operations)
- Whether to use React useBlocker for navigation warnings or handle it differently

### Deferred Ideas (OUT OF SCOPE)

None -- discussion stayed within phase scope
</user_constraints>

## Summary

This phase lifts the transcription state machine out of `ProjectPage` (component-local `useReducer`) into a root-level React Context provider (`TranscriptionProvider`) that wraps `BrowserRouter`, following the exact same `useReducer + createContext + Provider` pattern already established by `SettingsContext` and `ProjectsContext`. The key challenge is that the async `startTranscription` closure (which calls `uploadFile` then `generateTranscript`) must run independently of any component's mount lifecycle. The solution is straightforward: move the `useReducer`, `abortControllerRef`, and the `startTranscription`/`cancel`/`resume`/`reset` callbacks into the provider component itself. Since the provider lives above the router and never unmounts, the async Promise chain and its `dispatch` reference survive any route navigation.

A secondary concern is giving the user visibility into background operations: sidebar indicators (spinner for active, dot colors for interrupted/error), clickable toast notifications on completion/error while viewing other screens, and the ability to resume the live view seamlessly when navigating back. The toast system requires a new dependency (recommended: **sonner**). Sidebar indicators are CSS-only animations driven by the context state.

**Primary recommendation:** Create `TranscriptionContext` following the existing SettingsContext/ProjectsContext pattern, nest it at `SettingsProvider > ProjectsProvider > TranscriptionProvider > BrowserRouter` in App.tsx, add sonner for toast notifications, add a new `interrupted` ProjectStatus for reload detection, and use `beforeunload` for tab-close confirmation during active transcription.

## Standard Stack

### Core

| Library      | Version | Purpose                             | Why Standard                                                                              |
| ------------ | ------- | ----------------------------------- | ----------------------------------------------------------------------------------------- |
| react        | 18.3.1  | Context + useReducer for state      | Already in project; Context API is the established pattern                                |
| react-router | 7.13.0  | useBlocker for navigation awareness | Already in project; useBlocker is stable in v7                                            |
| sonner       | 2.0.7   | Toast notifications                 | ~2-3KB gzipped, zero dependencies, TypeScript-first, callable from anywhere without hooks |

### Supporting

| Library                     | Version | Purpose              | When to Use                               |
| --------------------------- | ------- | -------------------- | ----------------------------------------- |
| react-intersection-observer | 10.0.2  | Auto-scroll sentinel | Already in project for LiveTranscriptView |

### Alternatives Considered

| Instead of | Could Use               | Tradeoff                                                                                                                                                                    |
| ---------- | ----------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| sonner     | react-hot-toast         | react-hot-toast (~5KB) is more battle-tested but sonner has better TS support, smaller size, and toasts callable without hooks (critical for calling from context provider) |
| sonner     | Custom toast            | Hand-rolling toasts wastes time on animation, stacking, auto-dismiss, a11y -- use a library                                                                                 |
| useBlocker | Custom history listener | useBlocker is stable in react-router 7.13.0, no reason to hand-roll                                                                                                         |

**Installation:**

```bash
npm install sonner@2.0.7
```

## Architecture Patterns

### Recommended Project Structure

```
src/
├── contexts/
│   ├── SettingsContext.tsx        # Existing (unchanged)
│   ├── ProjectsContext.tsx        # Existing (unchanged)
│   └── TranscriptionContext.tsx   # NEW: lifted transcription state
├── features/
│   ├── project/
│   │   ├── hooks/
│   │   │   ├── useTranscription.ts     # GUTTED: becomes thin re-export of context
│   │   │   └── useAutoScroll.ts        # Existing (unchanged)
│   │   ├── components/
│   │   │   ├── LiveTranscriptView.tsx  # Existing (unchanged)
│   │   │   ├── ProgressStepper.tsx     # Existing (unchanged)
│   │   │   └── FileUpload.tsx          # Existing (unchanged)
│   │   └── ProjectPage.tsx             # SIMPLIFIED: consumes context, no longer owns state
│   ├── dashboard/
│   │   ├── components/
│   │   │   ├── Sidebar.tsx             # MODIFIED: spinner indicator, status dots from context
│   │   │   ├── ProjectEntry.tsx        # MODIFIED: spinner/indicator rendering
│   │   │   ├── CenterPanel.tsx         # MODIFIED: active transcription routing
│   │   │   └── TranscriptPanel.tsx     # MODIFIED: live view for active project
│   │   └── DashboardLayout.tsx         # Existing (minor: toast container)
│   └── settings/
│       ├── SettingsPage.tsx            # MODIFIED: API key warning during transcription
│       └── components/
│           └── ApiKeyForm.tsx          # MODIFIED: disable clear during active transcription
├── app/
│   ├── App.tsx                         # MODIFIED: add TranscriptionProvider + Toaster
│   └── Layout.tsx                      # Existing (unchanged)
└── services/
    ├── storageService.ts               # Existing (unchanged)
    ├── storageService.types.ts         # MODIFIED: add 'interrupted' status
    └── geminiService.ts                # Existing (unchanged)
```

### Pattern 1: Lifting State to Context Provider (Core Pattern)

**What:** Move the entire `useReducer` + async operation management from `useTranscription` hook into a `TranscriptionProvider` that wraps the router.

**When to use:** When component-local state must survive route navigation (the exact problem).

**Why it works:** The Provider component is rendered above `BrowserRouter` in the component tree. It never unmounts during SPA navigation. The `useReducer` dispatch function has a stable identity (React guarantees this), so the async Promise chain's closure over `dispatch` remains valid regardless of which child components mount/unmount.

**Architecture:**

```typescript
// TranscriptionContext.tsx

// State types (moved from useTranscription.ts)
// ... TranscriptionState, TranscriptionEvent, TranscriptionMachineState ...
// ... TRANSITIONS map, transcriptionReducer (all unchanged) ...

// NEW: Track which project is being transcribed
interface TranscriptionContextState extends TranscriptionMachineState {
  activeProjectId: string | null;  // Which project owns the current transcription
}

interface TranscriptionContextValue {
  state: TranscriptionContextState;
  startTranscription: (
    file: File,
    mimeType: string,
    duration: number,
    projectId: string
  ) => Promise<void>;
  cancel: () => void;
  reset: () => void;
  isTranscribing: boolean;  // Convenience: state is uploading/processing/cancelling
}

// Provider component owns the reducer and abortControllerRef
export function TranscriptionProvider({ children }: { children: React.ReactNode }) {
  const [machineState, dispatch] = useReducer(transcriptionReducer, initialState);
  const abortControllerRef = useRef<AbortController | null>(null);
  const [activeProjectId, setActiveProjectId] = useState<string | null>(null);

  // startTranscription, cancel, reset -- same logic as current useTranscription
  // but dispatch and abortControllerRef are owned by this Provider, not a component

  const value = useMemo(() => ({
    state: { ...machineState, activeProjectId },
    startTranscription,
    cancel,
    reset,
    isTranscribing: ['uploading', 'processing', 'cancelling'].includes(machineState.state),
  }), [machineState, activeProjectId]);

  return (
    <TranscriptionContext.Provider value={value}>
      {children}
    </TranscriptionContext.Provider>
  );
}
```

**Critical detail -- split state and dispatch contexts for performance:**
Components that only need `dispatch`/`startTranscription` (like FileUpload trigger) should NOT re-render on every state change. Split into two contexts:

```typescript
const TranscriptionStateContext = createContext<TranscriptionContextState | undefined>(undefined);
const TranscriptionActionsContext = createContext<TranscriptionActions | undefined>(undefined);

// Consumers:
export function useTranscriptionState() { ... }   // Re-renders on state change
export function useTranscriptionActions() { ... }  // Stable, never re-renders
```

Source: Established React pattern -- splitting state and dispatch contexts. See [React docs on Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context) and [4 options to prevent extra rerenders with React context](https://blog.axlight.com/posts/4-options-to-prevent-extra-rerenders-with-react-context/).

### Pattern 2: Provider Nesting Order

**What:** Place `TranscriptionProvider` between `ProjectsProvider` and `BrowserRouter`.

**Why:** TranscriptionProvider needs access to `ProjectsContext` (to call `updateProject` when transcription completes/errors/cancels in background). It does NOT need the router. The router DOES need access to transcription state (for `useBlocker`, sidebar indicators, etc.).

```typescript
// App.tsx
<SettingsProvider>
  <ProjectsProvider>
    <TranscriptionProvider>
      <BrowserRouter>
        <Toaster />  {/* sonner's Toaster */}
        <Routes>...</Routes>
      </BrowserRouter>
    </TranscriptionProvider>
  </ProjectsProvider>
</SettingsProvider>
```

**Decision from Phase 4:** Existing nesting is `SettingsProvider > ProjectsProvider > BrowserRouter` (decision 04-03). TranscriptionProvider slots in between ProjectsProvider and BrowserRouter.

### Pattern 3: New `interrupted` ProjectStatus for Reload Detection

**What:** Add `'interrupted'` to the `ProjectStatus` union type to distinguish "killed by browser refresh/crash" from "cancelled by user."

**How to detect:** In the `TranscriptionProvider`'s initialization:

1. On mount, check if any project has status `'uploading'` or `'processing'` but the TranscriptionContext state is `idle` (no active transcription running).
2. If found, that project was interrupted by a reload/crash. Update its status to `'interrupted'`.
3. This runs once on provider mount, before any user interaction.

**Why separate from `cancelled`:** User decided: different indicators, different implied actions. Cancelled = user chose to stop. Interrupted = unexpected, should offer resume.

```typescript
// storageService.types.ts
export type ProjectStatus =
  | 'idle'
  | 'uploading'
  | 'processing'
  | 'completed'
  | 'error'
  | 'cancelled'
  | 'interrupted'; // NEW
```

**Sidebar indicators (from decisions):**

- Active transcription (uploading/processing): animated spinner/pulse
- Interrupted: yellow/orange dot (distinct from cancelled amber dot)
- Cancelled: amber dot (existing)
- Error: red dot (existing)

### Pattern 4: Toast Notifications with Sonner

**What:** Use sonner for non-blocking clickable toast notifications.

**Setup:**

```typescript
// App.tsx -- add <Toaster /> inside BrowserRouter (needs access to navigate)
import { Toaster } from 'sonner';

// Inside BrowserRouter:
<Toaster position="bottom-right" richColors />
```

**Usage from context provider:**

```typescript
// TranscriptionContext.tsx
import { toast } from 'sonner';

// On completion while user is on a different screen:
toast.success(`Interview with ${projectName} -- transcription complete`, {
  action: {
    label: 'View',
    onClick: () => {
      // Navigate to project -- need to expose navigate from somewhere
      // Option: pass navigate via a ref set by a child component
    },
  },
  duration: 8000, // 8s auto-dismiss for important notifications
});
```

**Navigation from toast (architecture consideration):**
Sonner's `toast()` is callable from anywhere, but navigation (`useNavigate`) is only available inside the router. Since `TranscriptionProvider` is ABOVE `BrowserRouter`, it cannot directly call `useNavigate`.

**Solution:** Use a `NavigationRef` pattern -- a small component inside the router that sets a ref that the provider can use:

```typescript
// In a component inside BrowserRouter:
const navigate = useNavigate();
useEffect(() => {
  navigationRef.current = navigate;
}, [navigate]);

// TranscriptionProvider can then call:
navigationRef.current?.(`/project/${projectId}`);
```

Alternatively, nest `Toaster` inside the router and fire toasts from a `useEffect` in a component that has access to both transcription state and `useNavigate`.

### Pattern 5: Tab Close Protection with beforeunload

**What:** Show browser's native "Leave site?" confirmation dialog when user tries to close the tab during active transcription.

**How:**

```typescript
// Inside TranscriptionProvider:
useEffect(() => {
  if (!isTranscribing) return;

  const handleBeforeUnload = (e: BeforeUnloadEvent) => {
    e.preventDefault();
    // Also flush pending writes
    flushPendingWrites();
  };

  window.addEventListener('beforeunload', handleBeforeUnload);
  return () => window.removeEventListener('beforeunload', handleBeforeUnload);
}, [isTranscribing]);
```

**Note:** The existing `beforeunload` handler in `storageService.ts` only calls `flushPendingWrites`. The new handler in the provider adds the browser confirmation dialog (`e.preventDefault()`) and is only active during transcription. These do NOT conflict -- both listeners fire on the same event.

Source: [MDN beforeunload event](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event).

### Pattern 6: Reconnecting Live View on Navigation Return

**What:** When user navigates away from the active project and comes back, the live view (ProgressStepper + LiveTranscriptView) must resume seamlessly.

**How:** Since the transcription state lives in context (not component state), all data is already available:

- `machineState.state` tells us the current phase (uploading/processing/etc.)
- `machineState.transcript` has all accumulated segments
- `machineState.progress` has the current progress percentage

The `ProjectPage` component (or equivalent) simply reads from context and renders the appropriate UI. No "reconnection" logic needed -- the state was never lost.

**Key subtlety:** `useAutoScroll` will reset when the component remounts, so the scroll position resets to bottom on return. This is actually desirable (user returns and sees latest content).

### Anti-Patterns to Avoid

- **Moving the async Promise chain into a Web Worker or service worker:** Unnecessary complexity. The Promise runs on the main thread and persists as long as the closure's scope isn't garbage collected. Since `dispatch` (from the Provider's `useReducer`) and `abortControllerRef` (from the Provider's `useRef`) are both owned by the never-unmounting Provider, the closure survives route changes.
- **Storing transcription machine state in localStorage and re-hydrating:** The machine state is transient (progress percentage, current segment). Only segments and project status need persistence (already handled by `debouncedSaveTranscript`).
- **Using `useBlocker` to prevent navigation during transcription:** The user decision explicitly says "Free navigation always." Do NOT block navigation. Only show a toast when navigating away. `useBlocker` could optionally be used for the API key change warning on Settings page, but that is simpler to implement as a conditional disable + warning message on the form itself.
- **Putting Toaster component outside BrowserRouter:** Sonner works fine outside the router, but if toast `action.onClick` needs to trigger navigation, the click handler needs access to the router's navigate function. Place `Toaster` inside `BrowserRouter` or use a `NavigationRef` pattern.

## Don't Hand-Roll

| Problem                                 | Don't Build                                                               | Use Instead                                           | Why                                                                                                                                                                      |
| --------------------------------------- | ------------------------------------------------------------------------- | ----------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| Toast notifications                     | Custom toast system with portal, animations, stacking, auto-dismiss, a11y | sonner                                                | Toast libraries handle edge cases (multiple toasts, z-index, screen readers, animation cancellation, swipe-to-dismiss) that take significant time to build correctly     |
| Navigation blocking for API key warning | Custom history listener or route guards                                   | Conditional disable on the form + inline warning text | User decision says "warn if user tries to change/remove API key" -- a simple disabled state + warning text is sufficient; no need for route-level blocking               |
| Scroll position restoration             | Custom scroll manager                                                     | Let browser handle + useAutoScroll reset on mount     | The user decision says "resume live view exactly as if they never left" -- re-mounting LiveTranscriptView with latest context data + auto-scroll to bottom achieves this |

**Key insight:** The "lift to context" pattern is pure React -- no external state management library needed. The existing codebase already uses this exact pattern twice (SettingsContext, ProjectsContext). The only new dependency is sonner for toasts.

## Common Pitfalls

### Pitfall 1: Stale Closure over dispatch in Async Operation

**What goes wrong:** The `startTranscription` function captures `dispatch` in a closure. If `dispatch` changes identity between renders, the async operation's `dispatch` calls might target an old reducer.
**Why it happens:** This is a React concern when using `useCallback` with `useReducer`.
**How to avoid:** React guarantees that `dispatch` from `useReducer` has a stable identity -- it never changes. This is documented in the React docs. Do NOT include `dispatch` in `useCallback` dependency arrays (it's stable). The current codebase already handles this correctly with `useCallback(async (...) => { ... }, [])`.
**Warning signs:** Lint warnings asking to add `dispatch` to deps. Ignore them for `useReducer` dispatch.

### Pitfall 2: Context Value Object Identity Causing Unnecessary Re-renders

**What goes wrong:** If the context value is a new object on every render `{ state, startTranscription, ... }`, every consumer re-renders on every state change, even if they only use `startTranscription`.
**Why it happens:** React Context uses `Object.is` comparison on the value. New object = new reference = all consumers re-render.
**How to avoid:** Split into two contexts: `TranscriptionStateContext` (state object, changes often) and `TranscriptionActionsContext` (action functions, stable references via `useCallback`). Components that only trigger actions (FileUpload) use the actions context and don't re-render on progress updates.
**Warning signs:** Sidebar or FileUpload re-rendering 30+ times per second during transcription.

### Pitfall 3: Toast Navigation Ref Not Available

**What goes wrong:** Calling `navigationRef.current('/project/...')` before the router has mounted or after it unmounts throws or silently fails.
**Why it happens:** `TranscriptionProvider` is above `BrowserRouter`. If completion fires during the tiny window between provider mount and router mount, the ref is null.
**How to avoid:** Guard with `if (navigationRef.current)`. Alternatively, fire toasts from a `useEffect` in a component inside the router that watches transcription state changes.
**Warning signs:** "Cannot call navigate outside of a Router" errors in console.

### Pitfall 4: Race Between Provider Mount Interrupt Detection and ProjectsContext Load

**What goes wrong:** `TranscriptionProvider` checks for interrupted projects on mount, but `ProjectsContext` might not have loaded projects from localStorage yet.
**Why it happens:** Both providers run their `useEffect` initialization independently. `ProjectsContext` loads async (via `initializeStorage` + `getProjects`).
**How to avoid:** The interrupt detection in TranscriptionProvider must wait for `projectsState.initialized === true` before scanning for interrupted projects. Use a `useEffect` that depends on `projectsState.initialized`.
**Warning signs:** No interrupted projects detected on reload even though one was running.

### Pitfall 5: Multiple beforeunload Handlers Conflicting

**What goes wrong:** The existing `beforeunload` handler in `storageService.ts` calls `flushPendingWrites`. A new handler in TranscriptionProvider calls `e.preventDefault()` + flush. Both fire, but the order is undefined.
**Why it happens:** `addEventListener` allows multiple listeners on the same event.
**How to avoid:** Both handlers are additive, not conflicting. The storageService handler flushes writes. The provider handler shows the browser dialog AND flushes. Since flushPendingWrites is idempotent (clears the map after flush), calling it twice is safe. No action needed -- just be aware.
**Warning signs:** None expected. This is a non-issue but worth documenting.

### Pitfall 6: Interrupted Status Not in Validator

**What goes wrong:** Adding `'interrupted'` to `ProjectStatus` type but forgetting to add it to the `VALID_PROJECT_STATUSES` set in `storageService.ts` causes validation failures on read.
**Why it happens:** The validator uses a hardcoded Set, not derived from the type.
**How to avoid:** Update `VALID_PROJECT_STATUSES` in `storageService.ts` when adding the new status. Also need schema migration v2 -> v3 if existing projects could have the new status -- but since `interrupted` is only set at runtime (never persisted as initial state), no migration is needed. Just add it to the validator.
**Warning signs:** Projects showing as corrupted data after reload.

## Code Examples

Verified patterns from official sources and existing codebase:

### Creating the TranscriptionContext (following existing pattern)

```typescript
// src/contexts/TranscriptionContext.tsx
// Follows exact same pattern as SettingsContext.tsx and ProjectsContext.tsx

import React, {
  createContext,
  useCallback,
  useContext,
  useEffect,
  useMemo,
  useReducer,
  useRef,
  useState,
} from 'react';
import { TranscriptSegment } from '@/types';
import { getDecryptedKey } from '@/services/cryptoService';
import { uploadFile, generateTranscript } from '@/services/geminiService';
import {
  debouncedSaveTranscript,
  flushPendingWrites,
  saveTranscript,
} from '@/services/storageService';
import { useProjects } from '@/contexts/ProjectsContext';
import { toast } from 'sonner';

// ... State types, TRANSITIONS, reducer moved from useTranscription.ts ...

// Split contexts for performance
const TranscriptionStateContext = createContext<TranscriptionContextState | undefined>(undefined);
const TranscriptionActionsContext = createContext<TranscriptionActions | undefined>(undefined);

export function TranscriptionProvider({ children }: { children: React.ReactNode }) {
  const [machineState, dispatch] = useReducer(transcriptionReducer, initialState);
  const abortControllerRef = useRef<AbortController | null>(null);
  const [activeProjectId, setActiveProjectId] = useState<string | null>(null);
  const { state: projectsState, updateProject } = useProjects();

  // Detect interrupted projects on initialization
  useEffect(() => {
    if (!projectsState.initialized) return;
    // If any project has 'uploading' or 'processing' status but we have no active transcription,
    // it was interrupted by a reload/crash
    for (const project of projectsState.projects) {
      if (
        (project.status === 'uploading' || project.status === 'processing') &&
        machineState.state === 'idle'
      ) {
        updateProject({ ...project, status: 'interrupted' });
      }
    }
    // Only run once on initialization
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, [projectsState.initialized]);

  // beforeunload: show confirmation dialog during active transcription
  const isTranscribing = ['uploading', 'processing', 'cancelling'].includes(machineState.state);
  useEffect(() => {
    if (!isTranscribing) return;
    const handler = (e: BeforeUnloadEvent) => {
      e.preventDefault();
      flushPendingWrites();
    };
    window.addEventListener('beforeunload', handler);
    return () => window.removeEventListener('beforeunload', handler);
  }, [isTranscribing]);

  // ... startTranscription, cancel, reset callbacks (same logic as current hook) ...

  // Split value into state and actions for re-render optimization
  const stateValue = useMemo(() => ({
    ...machineState,
    activeProjectId,
    isTranscribing,
  }), [machineState, activeProjectId, isTranscribing]);

  const actionsValue = useMemo(() => ({
    startTranscription,
    cancel,
    reset,
  }), [startTranscription, cancel, reset]);

  return (
    <TranscriptionStateContext.Provider value={stateValue}>
      <TranscriptionActionsContext.Provider value={actionsValue}>
        {children}
      </TranscriptionActionsContext.Provider>
    </TranscriptionStateContext.Provider>
  );
}

// Hooks
export function useTranscriptionState(): TranscriptionContextState {
  const context = useContext(TranscriptionStateContext);
  if (context === undefined) {
    throw new Error('useTranscriptionState must be used within a TranscriptionProvider');
  }
  return context;
}

export function useTranscriptionActions(): TranscriptionActions {
  const context = useContext(TranscriptionActionsContext);
  if (context === undefined) {
    throw new Error('useTranscriptionActions must be used within a TranscriptionProvider');
  }
  return context;
}
```

### Sonner Toast Setup

```typescript
// App.tsx
import { Toaster } from 'sonner';

export default function App() {
  return (
    <SettingsProvider>
      <ProjectsProvider>
        <TranscriptionProvider>
          <BrowserRouter>
            <Toaster position="bottom-right" richColors closeButton />
            <Routes>
              <Route element={<Layout />}>
                {/* ... routes ... */}
              </Route>
            </Routes>
          </BrowserRouter>
        </TranscriptionProvider>
      </ProjectsProvider>
    </SettingsProvider>
  );
}
```

### Clickable Completion Toast

```typescript
// Fired from TranscriptionProvider when completion is detected
// and user is NOT viewing the active project
toast.success(`Transcription complete: ${projectName}`, {
  action: {
    label: 'View',
    onClick: () => navigationRef.current?.(`/project/${projectId}`),
  },
  duration: 8000,
});
```

### Sidebar Spinner for Active Transcription

```typescript
// In ProjectEntry.tsx -- read from transcription context
const transcriptionState = useTranscriptionState();
const isActivelyTranscribing =
  transcriptionState.activeProjectId === project.id &&
  transcriptionState.isTranscribing;

// Render spinner indicator
{isActivelyTranscribing && (
  <span className="ml-1.5 inline-block h-2 w-2 flex-shrink-0 animate-spin rounded-full border border-indigo-500 border-t-transparent" />
)}
```

### Interrupt Detection CSS Indicator

```typescript
// Yellow/orange dot for interrupted projects (distinct from cancelled amber)
{project.status === 'interrupted' && (
  <span
    className="ml-1.5 inline-block h-2 w-2 flex-shrink-0 rounded-full bg-orange-400 animate-pulse"
    title="Transcription interrupted -- click to resume"
  />
)}
```

### Navigation-Away Toast

```typescript
// In a component inside the router that watches route changes
// Use useEffect on location change to detect navigation away from active project
const location = useLocation();
const transcriptionState = useTranscriptionState();

useEffect(() => {
  if (
    transcriptionState.isTranscribing &&
    transcriptionState.activeProjectId &&
    !location.pathname.includes(transcriptionState.activeProjectId) &&
    !location.pathname.includes('/project/new')
  ) {
    toast('Transcription continuing in background', {
      duration: 3000,
    });
  }
}, [location.pathname]);
```

## State of the Art

| Old Approach               | Current Approach                      | When Changed | Impact                                         |
| -------------------------- | ------------------------------------- | ------------ | ---------------------------------------------- |
| Component-local useReducer | Root-level Context provider           | This phase   | State survives navigation                      |
| No background visibility   | Sidebar spinner + toast notifications | This phase   | User always knows what's happening             |
| Single `cancelled` status  | `cancelled` + `interrupted` statuses  | This phase   | Different UI and actions per interruption type |
| No tab-close protection    | beforeunload confirmation dialog      | This phase   | User warned before losing active transcription |

**Not changing:**

- The state machine transitions (TRANSITIONS map) -- unchanged
- The reducer logic -- moved but not modified
- The Gemini API integration (geminiService.ts) -- unchanged
- The storage layer (storageService.ts) -- unchanged except adding 'interrupted' to validator

## Open Questions

1. **NavigationRef vs useEffect Observer Pattern for Toast Navigation**
   - What we know: TranscriptionProvider is above BrowserRouter, so it cannot use `useNavigate`. Toasts need to navigate on click.
   - What's unclear: Which pattern is cleaner -- a mutable ref set by a child component, or firing toasts from a `useEffect` in a component inside the router?
   - Recommendation: Use the **useEffect observer pattern**. Create a small `TranscriptionWatcher` component inside `BrowserRouter` that watches `transcriptionState` changes and fires toasts with navigation. This keeps the Provider pure (no router dependency) and the watcher component has full access to `useNavigate`. The Provider only dispatches state changes; the watcher component reacts to them.

2. **Schema Migration for `interrupted` Status**
   - What we know: Adding `'interrupted'` to ProjectStatus union type and VALID_PROJECT_STATUSES set.
   - What's unclear: Whether a formal schema migration (v2 -> v3) is needed.
   - Recommendation: **No migration needed.** The `interrupted` status is only ever set at runtime (by TranscriptionProvider on initialization). It is never the initial status of a freshly created project. Existing projects in storage will have `uploading`/`processing` status which gets re-classified to `interrupted` on load. Just add it to the validator set and bump the schema version to 3 for safety.

3. **Toast Dismiss Timing**
   - What we know: Need toasts for: nav-away, completion, error
   - What's unclear: Exact timing for each
   - Recommendation: Nav-away toast: 3s auto-dismiss (brief informational). Completion toast: 8s (important, user should notice). Error toast: persistent (no auto-dismiss, user must click to dismiss or click the action to navigate).

## Sources

### Primary (HIGH confidence)

- Codebase analysis: `useTranscription.ts`, `SettingsContext.tsx`, `ProjectsContext.tsx`, `ProjectPage.tsx`, `App.tsx` -- direct code reading
- [React docs: Scaling Up with Reducer and Context](https://react.dev/learn/scaling-up-with-reducer-and-context) -- official pattern for useReducer + Context
- [React docs: useReducer](https://react.dev/reference/react/useReducer) -- dispatch stability guarantee
- [React Router API: useBlocker](https://reactrouter.com/api/hooks/useBlocker) -- stable in v7, API signature confirmed
- [MDN: beforeunload event](https://developer.mozilla.org/en-US/docs/Web/API/Window/beforeunload_event) -- e.preventDefault() pattern
- [sonner npm](https://www.npmjs.com/package/sonner) -- v2.0.7, zero dependencies, 12.5M weekly downloads

### Secondary (MEDIUM confidence)

- [4 options to prevent extra rerenders with React context](https://blog.axlight.com/posts/4-options-to-prevent-extra-rerenders-with-react-context/) -- split context pattern
- [Kent C. Dodds: How to use React Context effectively](https://kentcdodds.com/blog/how-to-use-react-context-effectively) -- co-location and split patterns
- [Sonner vs Toast comparison](https://www.oreateai.com/blog/sonner-vs-toast-a-deep-dive-into-react-notification-libraries/4596cec74c442a27834f2ec4b53b8eb2) -- size comparison verified
- [LogRocket: React toast libraries compared 2025](https://blog.logrocket.com/react-toast-libraries-compared-2025/) -- ecosystem survey

### Tertiary (LOW confidence)

- [The pitfalls of async operations via React Context API](https://medium.com/@albertogasparin/the-pitfalls-of-async-operations-via-react-context-api-ab987d4290e6) -- general guidance, not specific to this use case

## Metadata

**Confidence breakdown:**

- Standard stack: HIGH -- only one new dependency (sonner), everything else is existing React patterns already proven in this codebase
- Architecture: HIGH -- the "lift useReducer to context" pattern is a direct application of official React docs and matches the existing SettingsContext/ProjectsContext pattern in this codebase exactly
- Pitfalls: HIGH -- pitfalls identified through direct code analysis (closure behavior, re-render optimization, validator sync) rather than speculation

**Research date:** 2026-02-08
**Valid until:** 2026-03-08 (stable patterns, low churn risk)
