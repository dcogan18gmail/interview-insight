---
phase: 03-storage-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/storageService.types.ts
  - services/storageService.ts
autonomous: true

must_haves:
  truths:
    - 'localStorage schema is versioned and app migrates old data automatically without crashing'
    - 'App handles localStorage quota exceeded with clear error message (not silent failure)'
    - 'App handles corrupted localStorage data without crashing (fallback to defaults)'
  artifacts:
    - path: 'services/storageService.types.ts'
      provides: 'All TypeScript interfaces and types for storage layer'
      contains: 'StorageMeta'
      min_lines: 30
    - path: 'services/storageService.ts'
      provides: 'Core storage primitives: safeRead, safeWrite, migration runner, availability check, quota detection'
      exports:
        ['isStorageAvailable', 'initializeStorage', 'safeRead', 'safeWrite']
      min_lines: 80
  key_links:
    - from: 'services/storageService.ts'
      to: 'services/storageService.types.ts'
      via: 'import types'
      pattern: "import.*from.*storageService\\.types"
    - from: 'services/storageService.types.ts'
      to: 'types.ts'
      via: 'import TranscriptSegment'
      pattern: 'import.*TranscriptSegment.*from'
---

<objective>
Build the storage service types and core low-level primitives for the localStorage persistence layer.

Purpose: Establish the typed foundation and safety primitives (safeRead, safeWrite, schema versioning, migration runner, availability check, quota detection) that all higher-level storage operations depend on. This is the infrastructure layer -- no project/transcript CRUD yet.

Output: Two files -- `services/storageService.types.ts` (all type definitions) and `services/storageService.ts` (core primitives + migration infrastructure + initialization).
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-storage-foundation/03-RESEARCH.md

# Existing codebase files for reference

@types.ts
@services/cryptoService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create storage type definitions</name>
  <files>services/storageService.types.ts</files>
  <action>
Create `services/storageService.types.ts` with all type definitions for the storage layer. Follow the project's conventions (named exports, PascalCase interfaces).

Define these types:

1. **StorageMeta** -- schema version tracking:
   - `schemaVersion: number` (integer, starts at 1)
   - `lastUpdated: string` (ISO timestamp)

2. **ProjectMetadata** -- lightweight project info for dashboard listing:
   - `id: string` (UUID via crypto.randomUUID)
   - `name: string`
   - `createdAt: string` (ISO timestamp)
   - `updatedAt: string` (ISO timestamp)
   - `status: ProjectStatus` (see below)
   - `fileInfo: FileInfo` (see below)
   - `segmentCount: number` (summary stat to avoid loading transcript)

3. **FileInfo** -- nested in ProjectMetadata:
   - `name: string`
   - `type: string`
   - `size: number`
   - `duration: number`

4. **ProjectStatus** -- union type (not enum, for JSON serialization simplicity):
   `'idle' | 'uploading' | 'processing' | 'completed' | 'error'`

5. **TranscriptData** -- heavy per-project transcript:
   - `projectId: string`
   - `segments: TranscriptSegment[]` (import from `../types`)
   - `completedAt: string | null`

6. **WriteResult** -- result type for safe writes:
   `{ ok: true } | { ok: false; error: 'quota_exceeded' | 'storage_unavailable' | 'unknown'; message: string }`

7. **ParseResult<T>** -- generic result type for safe reads:
   `{ ok: true; data: T } | { ok: false; error: string }`

8. **Migration** -- migration definition:
   - `version: number`
   - `up: () => void`

9. **StorageKeys** -- const object with key patterns:

   ```typescript
   export const STORAGE_KEYS = {
     META: 'ii:meta',
     PROJECTS: 'ii:projects',
     transcript: (id: string) => `ii:transcript:${id}`,
   } as const;
   ```

10. **CURRENT_SCHEMA_VERSION** -- export const set to `1`.

All types use named exports. The `TranscriptSegment` type is imported from `../types` (reuse existing type, do not redefine).
</action>
<verify>Run `npx tsc --noEmit` -- should compile with zero errors.</verify>
<done>All storage layer types are defined, exported, and compile cleanly under TypeScript strict mode.</done>
</task>

<task type="auto">
  <name>Task 2: Create core storage primitives and migration infrastructure</name>
  <files>services/storageService.ts</files>
  <action>
Create `services/storageService.ts` with the core low-level storage primitives. Import all types from `./storageService.types`. Follow project conventions (named exports, camelCase functions, `[StorageService]` prefix for console logs).

Implement these functions:

**1. isStorageAvailable(): boolean**

- Test localStorage with write/read/delete cycle using `__storage_test__` key
- Return false (not throw) if localStorage is unavailable (e.g., private browsing)

**2. isQuotaExceededError(err: unknown): boolean**

- Check for DOMException with code 22, code 1014, name `QuotaExceededError`, or name `NS_ERROR_DOM_QUOTA_REACHED`
- Cross-browser compatible per research pitfall #1

**3. safeWrite(key: string, value: string): WriteResult**

- Wrap `localStorage.setItem` in try/catch
- On quota exceeded: return `{ ok: false, error: 'quota_exceeded', message: 'Storage is full. Please delete some projects to free up space.' }`
- On other DOMException: return `{ ok: false, error: 'storage_unavailable', message: 'Unable to save data. Your browser may be in private browsing mode.' }`
- On unknown error: return `{ ok: false, error: 'unknown', message: 'An unexpected error occurred while saving data.' }`
- On success: return `{ ok: true }`

**4. safeRead<T>(key: string, validate: (raw: unknown) => ParseResult<T>): T | null**

- Get item from localStorage; if null, return null
- Try JSON.parse; on SyntaxError, log warning with `[StorageService]` prefix, remove corrupted key, return null
- Run validate on parsed data; if not ok, log warning, remove corrupted key, return null
- Return validated data

**5. Validators** -- hand-rolled type guards wrapped as ParseResult-returning functions:

- `validateStorageMeta(raw: unknown): ParseResult<StorageMeta>` -- checks schemaVersion is number, lastUpdated is string
- `validateProjectMetadataArray(raw: unknown): ParseResult<ProjectMetadata[]>` -- checks array, each item has id/name/createdAt/updatedAt/status/fileInfo/segmentCount with correct types, status is valid ProjectStatus value
- `validateTranscriptData(raw: unknown): ParseResult<TranscriptData>` -- checks projectId is string, segments is array (light validation on segments -- just check array exists, individual segment validation is too strict for corruption recovery)

**6. Migration infrastructure:**

- `const migrations: Migration[] = [];` -- empty array for v1, ready for future schema changes
- `runMigrations(currentVersion: number, targetVersion: number): void` -- filters migrations between current and target, sorts by version, runs each in try/catch. On success, writes updated version to `ii:meta` via safeWrite. On failure, logs error with `[StorageService]` prefix and breaks (stops at last successful version).

**7. initializeStorage(): { available: boolean; error?: string }**

- Call isStorageAvailable(); if false, return `{ available: false, error: 'localStorage is not available' }`
- Read `ii:meta` via safeRead with validateStorageMeta
- If null (fresh install): write `{ schemaVersion: CURRENT_SCHEMA_VERSION, lastUpdated: new Date().toISOString() }` to `ii:meta` via safeWrite. Check WriteResult -- if not ok, return `{ available: false, error: result.message }`
- If version < CURRENT_SCHEMA_VERSION: run migrations
- If version > CURRENT_SCHEMA_VERSION: log warning `[StorageService] Unknown schema version ${version}, expected ${CURRENT_SCHEMA_VERSION}. Data may be from a newer app version.` -- proceed anyway (read-only compatible)
- Return `{ available: true }`

**8. getStorageUsageBytes(): number**

- Iterate all localStorage keys, sum `(key.length + value.length) * 2` (UTF-16 encoding)

**9. getStorageUsageMB(): number**

- Return `getStorageUsageBytes() / (1024 * 1024)` rounded to 2 decimal places

Do NOT implement project/transcript CRUD, debounced writes, or beforeunload handling in this task. Those belong in Plan 02.
</action>
<verify>
Run `npx tsc --noEmit` -- should compile with zero errors.
Run `npm run lint` -- should pass with no new errors.
Run `npm run build` -- should build successfully (Vite build).
</verify>
<done>Core storage primitives exist: safeRead/safeWrite handle corruption and quota gracefully, initializeStorage sets up schema versioning, migration infrastructure is ready for future use, validators guard all data shapes.</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes with no new errors
3. `npm run build` succeeds
4. `services/storageService.types.ts` exports all required types (StorageMeta, ProjectMetadata, TranscriptData, WriteResult, ParseResult, Migration, STORAGE_KEYS, CURRENT_SCHEMA_VERSION)
5. `services/storageService.ts` exports: isStorageAvailable, initializeStorage, safeRead, safeWrite, validateStorageMeta, validateProjectMetadataArray, validateTranscriptData, getStorageUsageBytes, getStorageUsageMB, runMigrations
6. No new npm dependencies added
</verification>

<success_criteria>

- Storage type definitions compile under TypeScript strict mode with no errors
- safeWrite returns structured WriteResult with quota_exceeded detection (not throwing)
- safeRead catches JSON.parse errors and validation failures, removes corrupted keys, returns null
- initializeStorage creates ii:meta with schemaVersion 1 on first run
- Migration runner exists and is wired to initializeStorage (even though migrations array is empty for v1)
- All validators return ParseResult<T> (not boolean type guards) for consistent error reporting
  </success_criteria>

<output>
After completion, create `.planning/phases/03-storage-foundation/03-01-SUMMARY.md`
</output>
