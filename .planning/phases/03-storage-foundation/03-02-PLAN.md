---
phase: 03-storage-foundation
plan: 02
type: execute
wave: 2
depends_on: ['03-01']
files_modified:
  - services/storageService.ts
autonomous: true

must_haves:
  truths:
    - 'Project state persists across page refresh and browser close'
    - 'Project metadata and transcript data use separate localStorage keys for lazy loading'
    - 'Deleting a project removes both metadata and transcript data (no orphans)'
    - 'Debounced writes batch rapid changes and flush on beforeunload'
  artifacts:
    - path: 'services/storageService.ts'
      provides: 'Complete storage service with project CRUD, transcript CRUD, debounced writes, public API'
      exports:
        [
          'getProjects',
          'getProject',
          'saveProject',
          'deleteProject',
          'getTranscript',
          'saveTranscript',
          'deleteTranscript',
          'flushPendingWrites',
          'initializeStorage',
        ]
      min_lines: 200
  key_links:
    - from: 'services/storageService.ts'
      to: 'localStorage ii:projects'
      via: 'safeRead/safeWrite with STORAGE_KEYS.PROJECTS'
      pattern: "STORAGE_KEYS\\.PROJECTS"
    - from: 'services/storageService.ts'
      to: 'localStorage ii:transcript:{id}'
      via: 'safeRead/safeWrite with STORAGE_KEYS.transcript(id)'
      pattern: "STORAGE_KEYS\\.transcript"
    - from: 'services/storageService.ts'
      to: 'types.ts TranscriptSegment'
      via: 'TranscriptData.segments uses TranscriptSegment type'
      pattern: 'TranscriptSegment'
---

<objective>
Build the project and transcript CRUD operations, debounced write system, and complete public API on top of the core primitives from Plan 01.

Purpose: Provide a complete, typed, quota-aware persistence API that Phases 4-6 will use for project management, transcript storage, and state persistence. After this plan, the storage layer is fully functional and ready for integration.

Output: Updated `services/storageService.ts` with all CRUD operations, debounced writes with beforeunload flush, orphan cleanup, and storage usage reporting.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-storage-foundation/03-RESEARCH.md
@.planning/phases/03-storage-foundation/03-01-SUMMARY.md

# Source files

@types.ts
@services/storageService.types.ts
@services/storageService.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add project and transcript CRUD operations</name>
  <files>services/storageService.ts</files>
  <action>
Add project and transcript CRUD functions to `services/storageService.ts`, building on the core primitives (safeRead, safeWrite, validators) from Plan 01.

**Project CRUD:**

1. **getProjects(): ProjectMetadata[]**
   - Read `ii:projects` via `safeRead` with `validateProjectMetadataArray`
   - Return empty array if null (fresh install or corrupted data = empty project list)

2. **getProject(id: string): ProjectMetadata | null**
   - Call `getProjects()`, find by id
   - Return null if not found

3. **saveProject(project: ProjectMetadata): WriteResult**
   - Read current projects array
   - If project.id exists in array, replace it (update); otherwise push (create)
   - Update project.updatedAt to current ISO timestamp
   - JSON.stringify the array and write to `ii:projects` via safeWrite
   - Return the WriteResult from safeWrite (caller handles quota errors)

4. **deleteProject(id: string): void**
   - Read current projects array
   - Filter out the project with matching id
   - Write updated array back to `ii:projects`
   - ALSO delete `ii:transcript:{id}` via `localStorage.removeItem(STORAGE_KEYS.transcript(id))` -- prevents orphaned transcript keys (pitfall #5 from research)
   - Log `[StorageService] Deleted project ${id} and associated transcript data`

5. **createProject(name: string, fileInfo: FileInfo): { project: ProjectMetadata; result: WriteResult }**
   - Generate id via `crypto.randomUUID()`
   - Create ProjectMetadata with: id, name, createdAt/updatedAt as current ISO timestamp, status 'idle', fileInfo, segmentCount 0
   - Call saveProject to persist
   - Return both the created project object and the WriteResult

**Transcript CRUD:**

6. **getTranscript(projectId: string): TranscriptData | null**
   - Read `ii:transcript:{projectId}` via `safeRead` with `validateTranscriptData`
   - Return null if not found or corrupted

7. **saveTranscript(data: TranscriptData): WriteResult**
   - JSON.stringify and write to `ii:transcript:{data.projectId}` via safeWrite
   - Also update the corresponding project's `segmentCount` in the projects array (read projects, find by id, update segmentCount to `data.segments.length`, write back). This keeps metadata in sync without loading transcript data.
   - Return WriteResult

8. **deleteTranscript(projectId: string): void**
   - Remove `ii:transcript:{projectId}` from localStorage
   - Log deletion

All functions use the existing safeRead/safeWrite primitives. No direct localStorage access except in deleteProject/deleteTranscript for removeItem (which cannot throw quota errors).
</action>
<verify>
Run `npx tsc --noEmit` -- should compile with zero errors.
Run `npm run lint` -- should pass.
</verify>
<done>All project and transcript CRUD operations are implemented with quota-aware writes, orphan prevention on delete, and segmentCount sync on transcript save.</done>
</task>

<task type="auto">
  <name>Task 2: Add debounced writes, beforeunload flush, orphan cleanup, and finalize public API</name>
  <files>services/storageService.ts</files>
  <action>
Add the debounced write system, beforeunload safety net, orphan cleanup utility, and ensure the complete public API is cleanly exported.

**Debounced Write System:**

1. Add module-level state:
   - `let pendingWrites: Map<string, string> = new Map();`
   - `let flushTimer: ReturnType<typeof setTimeout> | null = null;`

2. **debouncedWrite(key: string, value: string): void**
   - Add key/value to pendingWrites map
   - Clear existing flushTimer if set
   - Set new flushTimer for 300ms calling flushPendingWrites

3. **flushPendingWrites(): void**
   - Iterate pendingWrites, call safeWrite for each entry
   - Log any WriteResult errors with `[StorageService]` prefix (but don't throw -- best-effort flush)
   - Clear pendingWrites map and nullify flushTimer
   - Export this function so callers can force-flush (e.g., before navigation)

4. **Register beforeunload listener:**
   - `window.addEventListener('beforeunload', flushPendingWrites);`
   - Place this at module level so it registers on import
   - Guard with `typeof window !== 'undefined'` check for SSR safety (even though this app is client-only, it's good practice)

5. **Update saveProject to use debounced writes:**
   - Add an optional `immediate?: boolean` parameter to `saveProject` (default `false`)
   - When `immediate` is false: use `debouncedWrite` instead of `safeWrite` for the projects array write, and return `{ ok: true }` optimistically (the actual write happens on flush)
   - When `immediate` is true: use `safeWrite` directly and return the real WriteResult
   - `createProject` should always use `immediate: true` (new projects should persist immediately)
   - `saveTranscript` should always use `safeWrite` directly (transcript saves are infrequent and important)

**Orphan Cleanup:**

6. **cleanupOrphanedTranscripts(): number**
   - Get current project IDs from getProjects()
   - Iterate all localStorage keys
   - For any key matching `ii:transcript:*` pattern where the ID is NOT in the project list, remove it
   - Return count of orphaned keys removed
   - Log `[StorageService] Cleaned up ${count} orphaned transcript(s)`

**Storage Usage Reporting:**

7. **getStorageReport(): { usageMB: number; projectCount: number; available: boolean }**
   - Combine getStorageUsageMB(), getProjects().length, and isStorageAvailable()
   - Convenience function for future dashboard/settings UI

**Public API Export Summary:**

Ensure these are all exported (named exports):

- `initializeStorage` (from Plan 01)
- `isStorageAvailable` (from Plan 01)
- `getProjects`, `getProject`, `saveProject`, `deleteProject`, `createProject`
- `getTranscript`, `saveTranscript`, `deleteTranscript`
- `flushPendingWrites`
- `cleanupOrphanedTranscripts`
- `getStorageUsageBytes`, `getStorageUsageMB`, `getStorageReport`
- All validators (from Plan 01): `validateStorageMeta`, `validateProjectMetadataArray`, `validateTranscriptData`

Do NOT re-export types from this file -- types come from `storageService.types.ts`.
</action>
<verify>
Run `npx tsc --noEmit` -- should compile with zero errors.
Run `npm run lint` -- should pass with no errors.
Run `npm run build` -- should build successfully.
Verify the built output includes the storage service: check that `dist/` build succeeds (Vite tree-shakes unused exports, but the module should compile).
</verify>
<done>
Complete storage service is functional with:

- Project CRUD (create, read, update, delete) with quota-aware writes
- Transcript CRUD (read, save, delete) with separate keys per project
- Debounced writes (300ms) for rapid project metadata updates
- beforeunload flush to prevent data loss on tab close
- Orphan cleanup utility for transcript keys without parent projects
- Storage usage reporting
- All functions use safeRead/safeWrite primitives (no unguarded localStorage access)
  </done>
  </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes with no errors
3. `npm run build` succeeds
4. `services/storageService.ts` exports all CRUD functions (getProjects, getProject, saveProject, deleteProject, createProject, getTranscript, saveTranscript, deleteTranscript)
5. `services/storageService.ts` exports debounce functions (flushPendingWrites)
6. `services/storageService.ts` exports utility functions (cleanupOrphanedTranscripts, getStorageReport)
7. deleteProject calls both removeItem for transcript AND filters projects array (no orphans)
8. beforeunload listener is registered at module level
9. No new npm dependencies added
10. No direct localStorage.setItem/getItem calls outside of safeWrite/safeRead (except removeItem for deletes)
</verification>

<success_criteria>

- createProject generates UUID, persists immediately, returns both project and WriteResult
- saveProject supports debounced mode (default) and immediate mode
- deleteProject removes BOTH metadata entry and transcript key
- saveTranscript syncs segmentCount back to project metadata
- flushPendingWrites is callable externally and registered on beforeunload
- cleanupOrphanedTranscripts finds and removes transcript keys with no parent project
- All writes go through safeWrite (quota detection) except removeItem for deletes
- Complete typed public API ready for Phase 4 integration
  </success_criteria>

<output>
After completion, create `.planning/phases/03-storage-foundation/03-02-SUMMARY.md`
</output>
