---
phase: 06-enhanced-transcription-experience
plan: 02
type: execute
wave: 2
depends_on: ['06-01']
files_modified:
  - src/features/project/components/ProgressStepper.tsx
  - src/features/project/components/LiveTranscriptView.tsx
  - src/features/project/hooks/useAutoScroll.ts
  - src/index.css
  - package.json
autonomous: true

must_haves:
  truths:
    - 'User sees a horizontal stepper with 4 named stages and a unified progress bar underneath'
    - 'User sees transcript segments appear with a subtle fade-in animation'
    - 'Transcript auto-scrolls when user is at the bottom but holds position when scrolled up'
    - "A 'Jump to latest' pill appears when user scrolls away from the bottom"
    - 'The latest in-progress segment has a subtle pulse animation'
    - 'Time estimate shows approximate remaining time during transcription'
  artifacts:
    - path: 'src/features/project/components/ProgressStepper.tsx'
      provides: 'Horizontal stepper + progress bar combo with time estimate and cancel button slot'
      contains: 'ProgressStepper'
    - path: 'src/features/project/components/LiveTranscriptView.tsx'
      provides: 'Scrollable transcript display with auto-scroll, fade-in segments, jump-to-latest pill'
      contains: 'LiveTranscriptView'
    - path: 'src/features/project/hooks/useAutoScroll.ts'
      provides: 'Auto-scroll hook using IntersectionObserver sentinel pattern'
      contains: 'useAutoScroll'
  key_links:
    - from: 'src/features/project/components/LiveTranscriptView.tsx'
      to: 'src/features/project/hooks/useAutoScroll.ts'
      via: 'useAutoScroll hook provides refs and scroll controls'
      pattern: 'useAutoScroll'
    - from: 'src/features/project/components/LiveTranscriptView.tsx'
      to: 'react-intersection-observer'
      via: 'useInView for sentinel element visibility detection'
      pattern: 'useInView'
---

<objective>
Build the visual layer for live transcription: progress stepper with time estimation, auto-scrolling transcript display with fade-in segments, and "Jump to latest" pill.

Purpose: These are the presentation components that make the transcription process visible to the user. They consume the state machine data from Plan 01 but are self-contained UI building blocks.

Output: Three new files (ProgressStepper, LiveTranscriptView, useAutoScroll) plus CSS animation additions and react-intersection-observer dependency.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-enhanced-transcription-experience/06-CONTEXT.md
@.planning/phases/06-enhanced-transcription-experience/06-RESEARCH.md
@.planning/phases/06-enhanced-transcription-experience/06-01-SUMMARY.md
@src/types/index.ts
@src/index.css
@src/features/project/components/TranscriptView.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install react-intersection-observer, create useAutoScroll hook, and add CSS animations</name>
  <files>
package.json
src/features/project/hooks/useAutoScroll.ts
src/index.css
  </files>
  <action>
**Install dependency:**
```bash
npm install react-intersection-observer
```
Pin the installed version to exact (no caret/tilde) in package.json per project convention.

**Create useAutoScroll.ts:**

```typescript
import { useRef, useCallback, useEffect } from 'react';
import { useInView } from 'react-intersection-observer';

interface UseAutoScrollReturn {
  scrollContainerRef: React.RefObject<HTMLDivElement | null>;
  sentinelRef: (node?: Element | null) => void;
  isAtBottom: boolean;
  scrollToBottom: () => void;
}

export function useAutoScroll(deps: unknown[] = []): UseAutoScrollReturn {
  const scrollContainerRef = useRef<HTMLDivElement>(null);

  // IntersectionObserver on sentinel div at bottom of scroll content
  const { ref: sentinelRef, inView: isAtBottom } = useInView({
    threshold: 0,
  });

  // Scroll to bottom of the container
  const scrollToBottom = useCallback(() => {
    scrollContainerRef.current?.scrollTo({
      top: scrollContainerRef.current.scrollHeight,
      behavior: 'instant', // Use 'instant' for jump-to-latest (per research: avoids chasing during rapid arrivals)
    });
  }, []);

  // Auto-scroll when new content arrives AND user is at bottom
  useEffect(() => {
    if (isAtBottom) {
      scrollContainerRef.current?.scrollTo({
        top: scrollContainerRef.current.scrollHeight,
        behavior: 'smooth',
      });
    }
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, deps);

  return {
    scrollContainerRef,
    sentinelRef,
    isAtBottom,
    scrollToBottom,
  };
}
```

The `deps` parameter lets the consumer specify what triggers auto-scroll (e.g., `[segments.length]`). When deps change AND the user is at the bottom, it smooth-scrolls. The `scrollToBottom` function uses `'instant'` for the manual "Jump to latest" click.

**Add CSS animations to src/index.css:**

Add inside the existing `@layer utilities` block, after the existing `.animate-fade-in` rule:

```css
/* Fast fade-in for transcript segments (200ms) */
@keyframes fadeInFast {
  from {
    opacity: 0;
  }
  to {
    opacity: 1;
  }
}

.animate-fade-in-fast {
  animation: fadeInFast 0.2s ease-out forwards;
}

/* Subtle shimmer for in-progress segment */
@keyframes shimmer {
  0%,
  100% {
    opacity: 1;
  }
  50% {
    opacity: 0.7;
  }
}

.animate-shimmer {
  animation: shimmer 2s ease-in-out infinite;
}
```

The fade-in-fast animation is 200ms (per research discretion recommendation) for segment arrival. The shimmer animation is for the latest in-progress segment (per user decision: "subtle pulse/shimmer").
</action>
<verify>

1. `npm ls react-intersection-observer` shows the installed version
2. Verify the version in package.json has no caret/tilde prefix
3. `npx tsc --noEmit` passes
4. The CSS file contains both `animate-fade-in-fast` and `animate-shimmer` classes
   </verify>
   <done>
   react-intersection-observer is installed and pinned, useAutoScroll hook provides sentinel-based auto-scroll with IntersectionObserver, CSS has segment fade-in and shimmer animations.
   </done>
   </task>

<task type="auto">
  <name>Task 2: Build ProgressStepper and LiveTranscriptView components</name>
  <files>
src/features/project/components/ProgressStepper.tsx
src/features/project/components/LiveTranscriptView.tsx
  </files>
  <action>
**Create ProgressStepper.tsx:**

A combo component showing a horizontal stepper with 4 discrete stages and a unified progress bar underneath, per the user's locked decision.

Props interface:

```typescript
interface ProgressStepperProps {
  currentStage: 'uploading' | 'processing' | 'transcribing' | 'complete';
  progress: number; // 0-100 unified progress
  timeEstimate: string | null; // e.g., "~2 min remaining" or null if too early
  onCancel?: () => void; // Cancel button callback (optional -- hidden when not provided)
  isComplete?: boolean; // Triggers the completion transition
}
```

Stage display logic:

- Define `STAGES = ['Uploading', 'Processing', 'Transcribing', 'Complete'] as const`
- Map currentStage to an index (0-3)
- Past stages: filled dot (bg-indigo-600), bold text (text-indigo-700)
- Current stage: pulsing dot (animate-pulse bg-indigo-600), bold text
- Future stages: empty dot (bg-slate-200), muted text (text-slate-400)
- Connector lines between stages: filled (bg-indigo-600) for completed, empty (bg-slate-200) for pending

Progress bar:

- Full width, rounded, h-2
- Fill uses `bg-indigo-600` with `transition-all duration-500 ease-out`
- Width set via inline style `width: ${progress}%`
- On completion (`isComplete && progress >= 100`): briefly flash `bg-green-500` for 1 second using a local state timer, then the component should start fading out with `opacity-0 transition-opacity duration-1000`

Time estimate + Cancel row:

- Left side: time estimate text (text-xs text-slate-500) or "Estimating..." if null
- Right side: Cancel button (text-xs text-slate-400 hover:text-red-500 transition-colors) -- only rendered when `onCancel` is provided
- Cancel button text: "Cancel"

Time estimation utility (implement inside the file or as a helper):

```typescript
function estimateRemainingTime(
  progressPercent: number,
  elapsedMs: number
): string | null {
  if (progressPercent < 5 || elapsedMs < 3000) return null;
  const remainingPercent = 100 - progressPercent;
  const msPerPercent = elapsedMs / progressPercent;
  const remainingMs = remainingPercent * msPerPercent;
  const remainingMinutes = Math.ceil(remainingMs / 60000);
  if (remainingMinutes <= 1) return '< 1 min remaining';
  return `~${remainingMinutes} min remaining`;
}
```

The component should track `startTime` via `useRef(Date.now())` to compute elapsed time, and recalculate the estimate on each progress change.

Placement: This component is rendered inline above the transcript content (scrolls away as transcript grows, not sticky) per user decision.

**Create LiveTranscriptView.tsx:**

A scrollable container that renders growing transcript segments with auto-scroll, fade-in animation, shimmer on the latest segment, and a "Jump to latest" pill.

Props interface:

```typescript
interface LiveTranscriptViewProps {
  segments: TranscriptSegment[];
  staleSegments?: TranscriptSegment[]; // Dimmed old segments during re-transcription
  isStreaming: boolean; // Whether transcription is actively in progress
}
```

Structure:

```
<div ref={scrollContainerRef} className="relative overflow-y-auto h-full">
  {/* Stale segments (dimmed) if re-transcribing */}
  {staleSegments?.map((seg, i) => (
    <div key={`stale-${i}`} className="opacity-40">
      <SegmentRow segment={seg} />
    </div>
  ))}

  {/* Live segments with fade-in */}
  {segments.map((seg, i) => {
    const isLatest = isStreaming && i === segments.length - 1;
    return (
      <div
        key={`live-${i}-${seg.timestamp}`}
        className={`animate-fade-in-fast ${isLatest ? 'animate-shimmer' : ''}`}
      >
        <SegmentRow segment={seg} />
      </div>
    );
  })}

  {/* Sentinel for auto-scroll detection */}
  <div ref={sentinelRef} className="h-1" />
</div>

{/* Jump to latest pill */}
{!isAtBottom && isStreaming && (
  <button
    onClick={scrollToBottom}
    className="absolute bottom-4 left-1/2 -translate-x-1/2 z-10
      rounded-full bg-indigo-600 px-4 py-1.5 text-xs font-medium text-white
      shadow-lg transition-all hover:bg-indigo-700"
  >
    Jump to latest
  </button>
)}
```

Use the `useAutoScroll` hook: pass `[segments.length]` as deps so it auto-scrolls on new segments.

SegmentRow sub-component (inline or extracted):

- Show speaker name in a small badge (rounded bg-indigo-100 text-indigo-700 text-xs font-bold uppercase)
- Show timestamp formatted as MM:SS (using `Math.floor(timestamp / 60)` and `timestamp % 60`)
- Show englishText as the primary text (text-base text-slate-800 leading-relaxed)
- Show originalText below if different from englishText (text-sm italic text-slate-400)
- This mirrors the segment display pattern from the existing TranscriptView component

The outer container must have `position: relative` so the pill is positioned correctly. Use `overflow-y-auto` and accept a height constraint from the parent (e.g., `h-full` or a max-height).

Export as the default export.
</action>
<verify>

1. `npx tsc --noEmit` passes
2. `npx eslint src/features/project/components/ProgressStepper.tsx src/features/project/components/LiveTranscriptView.tsx` passes
3. ProgressStepper accepts currentStage, progress, timeEstimate, onCancel props
4. LiveTranscriptView renders segments with fade-in, shimmer on latest, and jump-to-latest pill
5. Both components use Tailwind classes consistent with existing design system (indigo accent, slate text)
   </verify>
   <done>
   ProgressStepper shows horizontal stepper + progress bar + time estimate + cancel button. LiveTranscriptView renders growing segments with auto-scroll, fade-in animation, shimmer on latest, dimmed stale segments, and "Jump to latest" pill.
   </done>
   </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npx eslint src/features/project/components/ProgressStepper.tsx src/features/project/components/LiveTranscriptView.tsx src/features/project/hooks/useAutoScroll.ts` passes
3. react-intersection-observer is installed and pinned to exact version
4. CSS contains animate-fade-in-fast (200ms) and animate-shimmer (2s) animations
5. ProgressStepper renders 4 stages: Uploading, Processing, Transcribing, Complete
6. LiveTranscriptView uses useAutoScroll with IntersectionObserver sentinel
</verification>

<success_criteria>

- ProgressStepper shows stepper dots, labels, connector lines, progress bar, time estimate, and optional cancel button
- LiveTranscriptView auto-scrolls on new segments when at bottom, holds position when scrolled up
- "Jump to latest" pill appears when user scrolls away, disappears when at bottom
- Latest in-progress segment has shimmer animation
- Stale segments render at 40% opacity during re-transcription
- Segment fade-in uses 200ms animation
- Time estimate calculates remaining time from progress and elapsed time
- Completion triggers green flash then fade-out on progress bar
  </success_criteria>

<output>
After completion, create `.planning/phases/06-enhanced-transcription-experience/06-02-SUMMARY.md`
</output>
