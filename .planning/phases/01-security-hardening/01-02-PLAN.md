---
phase: 01-security-hardening
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - netlify/edge-functions/proxy-upload.ts
  - netlify/functions/gemini-upload.ts
autonomous: true

must_haves:
  truths:
    - 'Edge function proxy rejects requests from non-allowed origins'
    - "Edge function proxy rejects upload URLs that don't point to generativelanguage.googleapis.com"
    - 'Serverless function accepts API key from X-Gemini-Key request header instead of server env var'
    - 'Error responses contain only generic user-friendly messages, not raw API errors or stack traces'
    - 'Both functions have rate limiting configured'
  artifacts:
    - path: 'netlify/edge-functions/proxy-upload.ts'
      provides: 'Hardened upload proxy with CORS restriction, SSRF prevention, rate limiting, error sanitization'
      contains: 'ALLOWED_ORIGINS'
    - path: 'netlify/functions/gemini-upload.ts'
      provides: 'v2 format upload initiation with BYOK header support, rate limiting, error sanitization'
      contains: 'rateLimit'
  key_links:
    - from: 'netlify/edge-functions/proxy-upload.ts'
      to: 'https://generativelanguage.googleapis.com'
      via: 'URL allowlist validation before proxy'
      pattern: 'isAllowedUploadUrl'
    - from: 'netlify/functions/gemini-upload.ts'
      to: 'client request headers'
      via: 'X-Gemini-Key header for BYOK'
      pattern: 'X-Gemini-Key'
---

<objective>
Harden the two server-side functions: lock down CORS, prevent SSRF, sanitize errors, add rate limiting, and prepare for BYOK by accepting the API key from the client.

Purpose: These changes close the five server-side security vulnerabilities identified in the research: wildcard CORS (SEC-05), no URL validation / SSRF (SEC-06), raw error messages (SEC-08), no rate limiting (SEC-09), and embedded API key dependency (supports SEC-04).

Output: Hardened `proxy-upload.ts` and `gemini-upload.ts` with all security controls in place.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-hardening/01-RESEARCH.md

Key source files (READ these before modifying):
@netlify/edge-functions/proxy-upload.ts — Current edge function (wildcard CORS, no URL validation)
@netlify/functions/gemini-upload.ts — Current v1 serverless function (env var API key, raw errors)
@netlify.toml — Edge function routing configuration
</context>

<tasks>

<task type="auto">
  <name>Task 1: Harden proxy-upload.ts with CORS restriction, SSRF prevention, rate limiting, and error sanitization</name>
  <files>netlify/edge-functions/proxy-upload.ts</files>
  <action>
Rewrite `netlify/edge-functions/proxy-upload.ts` with the following changes. Keep the core proxy logic (forward PUT request body to Google upload URL) but add security layers:

**1. CORS Origin Allowlist (SEC-05):**
Define constant:

```typescript
const ALLOWED_ORIGINS = [
  'https://celebrated-selkie-3cbc3b.netlify.app',
  'http://localhost:3000',
  'http://localhost:8888',
];
```

Create helper `getCorsHeaders(request: Request): Record<string, string>` that:

- Gets `Origin` header from request
- Checks if origin is in `ALLOWED_ORIGINS`
- If allowed: sets `Access-Control-Allow-Origin` to the request origin
- If NOT allowed: sets `Access-Control-Allow-Origin` to empty string `""`
- Always includes `Vary: Origin` header (critical for CDN caching correctness)
- Includes `Access-Control-Allow-Methods: "PUT, OPTIONS"`
- Includes `Access-Control-Allow-Headers: "Content-Type, X-Upload-Url, Content-Range, X-Goog-Upload-Command, X-Goog-Upload-Offset"`

Replace ALL instances of `"Access-Control-Allow-Origin": "*"` with the dynamic origin from `getCorsHeaders()`.

**2. SSRF Prevention via URL Allowlist (SEC-06):**
Create helper `isAllowedUploadUrl(url: string): boolean` that:

- Parses the URL with `new URL(url)` in a try-catch (return false on parse failure)
- Validates: `parsed.protocol === "https:"` AND `parsed.hostname === "generativelanguage.googleapis.com"` AND `parsed.pathname.startsWith("/upload/")`
- Returns true only if all three conditions pass

Add validation BEFORE the proxy fetch:

```typescript
const uploadUrl = request.headers.get('X-Upload-Url');
if (!uploadUrl || !isAllowedUploadUrl(uploadUrl)) {
  return new Response(JSON.stringify({ error: 'Invalid upload URL' }), {
    status: 400,
    headers: { ...getCorsHeaders(request), 'Content-Type': 'application/json' },
  });
}
```

**3. Error Sanitization (SEC-08):**
Replace the catch block error response:

- BEFORE: `new Response(\`Proxy Error: ${String(error)}\`, ...)`
- AFTER: `console.error("[proxy-upload] Error:", error);` then return `new Response(JSON.stringify({ error: "Upload proxy error. Please try again." }), { status: 500, headers: { ...getCorsHeaders(request), "Content-Type": "application/json" } })`

**4. Rate Limiting (SEC-09):**
Add Config export with rate limiting:

```typescript
import type { Config, Context } from '@netlify/edge-functions';

export const config: Config = {
  path: '/proxy-upload',
  rateLimit: {
    windowLimit: 100,
    windowSize: 60,
    aggregateBy: ['ip', 'domain'],
  },
};
```

**5. Preserve existing proxy logic:**
The core logic stays the same: read headers (Content-Length, Content-Range, X-Goog-Upload-Command, X-Goog-Upload-Offset), forward PUT request with streaming body to Google, return Google's response with CORS headers attached.

**Important:** Keep the import of `Context` from `@netlify/edge-functions`. Add `Config` to the import. The default export function signature stays `async (request: Request, context: Context)`.
</action>
<verify>
Read the file and verify: (1) No `"*"` remains in any CORS header, (2) `isAllowedUploadUrl` function exists and checks hostname + protocol + pathname, (3) `ALLOWED_ORIGINS` array includes production URL and localhost URLs, (4) `config` export includes `rateLimit`, (5) Error catch block uses `console.error` + generic message (no `String(error)` in response body), (6) `Vary: Origin` header is included.
</verify>
<done>
`proxy-upload.ts` has: CORS restricted to allowlist with Vary header, SSRF prevention via URL validation, rate limiting (100/60s), sanitized error responses. No wildcard CORS remains. Core proxy streaming logic preserved.
</done>
</task>

<task type="auto">
  <name>Task 2: Migrate gemini-upload.ts to v2 format with BYOK header support, rate limiting, and error sanitization</name>
  <files>netlify/functions/gemini-upload.ts</files>
  <action>
Rewrite `netlify/functions/gemini-upload.ts` from Netlify Functions v1 format to v2 format. This is required for rate limiting support and modernizes the API.

**1. Migrate to v2 Format:**

- REMOVE: `import { Handler } from '@netlify/functions';` and `const handler: Handler = async (event) => {`
- REMOVE: `export { handler };`
- ADD: `import type { Config, Context } from "@netlify/functions";`
- ADD: Default export: `export default async (request: Request, context: Context) => {`
- Change method check from `event.httpMethod !== 'POST'` to `request.method !== "POST"`
- Change body parsing from `JSON.parse(event.body || '{}')` to `await request.json()`
- Change return format from `{ statusCode: N, body: "..." }` to `new Response("...", { status: N, headers: { "Content-Type": "application/json" } })`

**2. BYOK API Key from Client Header (supports SEC-04):**
The function currently reads `process.env.GEMINI_API_KEY`. Change to:

- First try to get API key from request header: `request.headers.get("X-Gemini-Key")`
- Fall back to `Deno.env.get("GEMINI_API_KEY")` or `process.env.GEMINI_API_KEY` (for backward compatibility during transition)
- If neither exists, return 401 with `{ error: "API key required. Please configure your Gemini API key in Settings." }`

```typescript
const apiKey =
  request.headers.get('X-Gemini-Key') || process.env.GEMINI_API_KEY;
if (!apiKey) {
  return new Response(
    JSON.stringify({
      error:
        'API key required. Please configure your Gemini API key in Settings.',
    }),
    { status: 401, headers: { 'Content-Type': 'application/json' } }
  );
}
```

**3. Error Sanitization (SEC-08):**
Replace the two error return points:

Error point 1 (no upload URL from Google):

- BEFORE: `return { statusCode: 500, body: \`Google API Error (${response.status} ${response.statusText}): ${text}\` };`
- AFTER: `console.error(\`[gemini-upload] Google API error: ${response.status} ${response.statusText} - ${text}\`);`then`return new Response(JSON.stringify({ error: "Failed to initiate upload. Please check your API key and try again." }), { status: 502, headers: { "Content-Type": "application/json" } });`

Error point 2 (catch block):

- BEFORE: `return { statusCode: 500, body: String(error) };`
- AFTER: `console.error("[gemini-upload] Unexpected error:", error);` then `return new Response(JSON.stringify({ error: "An unexpected error occurred. Please try again." }), { status: 500, headers: { "Content-Type": "application/json" } });`

**4. Rate Limiting (SEC-09):**
Add config export:

```typescript
export const config: Config = {
  path: '/api/gemini-upload',
  rateLimit: {
    windowLimit: 20,
    windowSize: 60,
    aggregateBy: ['ip', 'domain'],
  },
};
```

**5. Remove GoogleAIFileManager import:**
The current code imports `GoogleAIFileManager` from `@google/genai/server` but doesn't actually use it (the function makes raw fetch calls instead). Remove this unused import.

**6. Update netlify.toml if needed:**
If the v2 function's `path` config changes the endpoint URL, the client code in `geminiService.ts` (Plan 03) will need to use the new path. The v2 `path: "/api/gemini-upload"` means the function will be accessible at `/api/gemini-upload` instead of `/.netlify/functions/gemini-upload`. However, the old path `/.netlify/functions/gemini-upload` may still work as a fallback. To be safe, keep the path as `"/api/gemini-upload"` and update the client in Plan 03.

**Important notes:**

- The v2 format uses Web-standard `Request`/`Response` objects (same as edge functions)
- The `fetch` call to Google API remains the same (it's standard `fetch`)
- The function still reads `name`, `size`, `mimeType` from the request body and calls Google's resumable upload endpoint
  </action>
  <verify>
  Read the file and verify: (1) No `Handler` import or `export { handler }` remains, (2) Default export with `(request: Request, context: Context)` signature, (3) `X-Gemini-Key` header is read, (4) `config` export includes `rateLimit`, (5) No raw error details in response bodies (search for `String(error)` and API response text in return statements), (6) `GoogleAIFileManager` import is removed, (7) All responses use `new Response()` with JSON body and Content-Type header.
  </verify>
  <done>
  `gemini-upload.ts` is in v2 format with: BYOK support via X-Gemini-Key header, server env var fallback, rate limiting (20/60s), sanitized error responses, unused import removed. All responses are JSON with Content-Type headers.
  </done>
  </task>

</tasks>

<verification>
1. `proxy-upload.ts`: grep for `"*"` — must return zero matches (no wildcard CORS)
2. `proxy-upload.ts`: `isAllowedUploadUrl` function validates protocol + hostname + pathname
3. `proxy-upload.ts`: `config` export with `rateLimit`
4. `gemini-upload.ts`: No `Handler` import, has default export
5. `gemini-upload.ts`: Reads `X-Gemini-Key` header
6. `gemini-upload.ts`: `config` export with `rateLimit`
7. Both files: grep for `String(error)` in response bodies — must return zero matches
8. Both files: All error responses use `JSON.stringify({ error: "..." })` with generic messages
</verification>

<success_criteria>

- Edge function CORS restricted to origin allowlist (no wildcard)
- Edge function validates upload URLs against Google API hostname
- Serverless function accepts API key via header (BYOK-ready)
- Both functions have rate limiting configured
- All error responses are sanitized — generic messages only
- Both functions use modern patterns (v2 format for gemini-upload)
  </success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-02-SUMMARY.md`
</output>
