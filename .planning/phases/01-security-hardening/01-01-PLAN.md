---
phase: 01-security-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - services/cryptoService.ts
  - netlify.toml
autonomous: true

must_haves:
  truths:
    - 'API keys can be encrypted and decrypted using Web Crypto AES-GCM with PBKDF2 key derivation'
    - 'Encrypted data survives round-trip: encrypt then decrypt returns original plaintext'
    - 'Each encryption produces unique ciphertext (fresh salt + IV every time)'
    - 'Security headers are served on all responses from the Netlify site'
  artifacts:
    - path: 'services/cryptoService.ts'
      provides: 'AES-GCM encryption/decryption with PBKDF2, passphrase management, Gemini key validation'
      exports:
        [
          'encryptApiKey',
          'decryptApiKey',
          'getOrCreatePassphrase',
          'validateGeminiApiKey',
          'hasStoredKey',
          'clearStoredKey',
          'getDecryptedKey',
        ]
    - path: 'netlify.toml'
      provides: 'Security headers configuration'
      contains: 'Content-Security-Policy'
  key_links:
    - from: 'services/cryptoService.ts'
      to: 'localStorage'
      via: 'getItem/setItem for encrypted key and passphrase'
      pattern: "localStorage\\.(get|set)Item"
    - from: 'services/cryptoService.ts'
      to: 'https://generativelanguage.googleapis.com'
      via: 'fetch for API key validation'
      pattern: "generativelanguage\\.googleapis\\.com/v1beta/models"
---

<objective>
Create the encryption foundation for BYOK API key storage and configure production security headers.

Purpose: These are independent building blocks needed by the Settings UI (Plan 02/03) and server hardening. The crypto service provides encrypt/decrypt/validate functions. Security headers protect the deployed site immediately.

Output: `services/cryptoService.ts` module with complete BYOK key management, and `netlify.toml` with security headers.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-hardening/01-RESEARCH.md

Key source files to reference:
@services/geminiService.ts — Current API key usage pattern (line 6-15, `getAI()` singleton)
@netlify.toml — Current config (no headers section)
@index.html — Uses Google Fonts CDN (affects CSP font-src/style-src)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create cryptoService.ts with AES-GCM encryption, passphrase management, and Gemini key validation</name>
  <files>services/cryptoService.ts</files>
  <action>
Create `services/cryptoService.ts` with these exports using ONLY the Web Crypto API (no npm dependencies):

**Constants:**

- `STORAGE_KEY_ENCRYPTED = "gemini_encrypted_key"` — localStorage key for encrypted API key
- `STORAGE_KEY_PASSPHRASE = "gemini_key_passphrase"` — localStorage key for app-generated passphrase

**Internal functions:**

- `deriveKey(passphrase: string, salt: Uint8Array): Promise<CryptoKey>` — PBKDF2 key derivation with 100,000 iterations, SHA-256 hash, producing AES-GCM 256-bit key. The key must be non-extractable with `["encrypt", "decrypt"]` usages.

**Exported functions:**

1. `encryptApiKey(apiKey: string, passphrase: string): Promise<string>` — Generate random 16-byte salt and 12-byte IV via `crypto.getRandomValues()`. Derive key via PBKDF2. Encrypt with AES-GCM. Concatenate `salt(16) + iv(12) + ciphertext` into a single Uint8Array. Return base64-encoded string via `btoa(String.fromCharCode(...combined))`.

2. `decryptApiKey(storedData: string, passphrase: string): Promise<string>` — Decode base64 to Uint8Array. Slice: `salt = [0:16]`, `iv = [16:28]`, `ciphertext = [28:]`. Derive key via PBKDF2 with same salt. Decrypt with AES-GCM. Return plaintext string via `TextDecoder`.

3. `getOrCreatePassphrase(): string` — Check `localStorage.getItem(STORAGE_KEY_PASSPHRASE)`. If exists, return it. If not, generate a 32-character random passphrase using `crypto.getRandomValues(new Uint8Array(24))` converted to base64, store it, and return it. This is the app-generated passphrase per the research recommendation (Option 1).

4. `validateGeminiApiKey(apiKey: string): Promise<{ valid: boolean; error?: string }>` — Make GET request to `https://generativelanguage.googleapis.com/v1beta/models?key=${apiKey}&pageSize=1`. Return `{ valid: true }` on 200 OK. Return `{ valid: false, error: "Invalid API key" }` on 4xx. Return `{ valid: false, error: "Could not validate key. Check your network connection." }` on network error. Use try-catch, never throw.

5. `hasStoredKey(): boolean` — Returns `!!localStorage.getItem(STORAGE_KEY_ENCRYPTED)`.

6. `clearStoredKey(): void` — Remove both `STORAGE_KEY_ENCRYPTED` and `STORAGE_KEY_PASSPHRASE` from localStorage.

7. `getDecryptedKey(): Promise<string | null>` — If no stored key, return null. Otherwise get passphrase and decrypt. On failure (corrupted data, wrong passphrase), call `clearStoredKey()` and return null.

**Important implementation notes:**

- Use `TextEncoder` for string-to-ArrayBuffer encoding
- Use `TextDecoder` for ArrayBuffer-to-string decoding
- All crypto operations are async (Web Crypto API returns Promises)
- Follow existing codebase conventions: camelCase functions, named exports, double quotes, 2-space indent
- Do NOT import any npm packages — everything is browser-native
  </action>
  <verify>
  Run `npx tsc --noEmit` from project root — no type errors in cryptoService.ts. Visually verify the file exports all 7 functions. Check that `crypto.subtle` is used (not `crypto-js` or any import).
  </verify>
  <done>
  `services/cryptoService.ts` exists with all 7 exported functions. Uses only Web Crypto API. TypeScript compiles without errors. Encrypt/decrypt are inverse operations. Fresh salt+IV generated on every encrypt call.
  </done>
  </task>

<task type="auto">
  <name>Task 2: Add security headers to netlify.toml</name>
  <files>netlify.toml</files>
  <action>
Add a `[[headers]]` section to `netlify.toml` AFTER the existing content. Apply to all paths (`for = "/*"`).

Headers to add (all under `[headers.values]`):

- `X-Frame-Options = "DENY"`
- `X-Content-Type-Options = "nosniff"`
- `X-XSS-Protection = "1; mode=block"` (legacy browser coverage)
- `Referrer-Policy = "strict-origin-when-cross-origin"`
- `Strict-Transport-Security = "max-age=31536000; includeSubDomains"`
- `Permissions-Policy = "camera=(), microphone=(), geolocation=()"`
- `Content-Security-Policy` — This is the most complex one. Build it as:
  - `default-src 'self';`
  - `script-src 'self';`
  - `style-src 'self' 'unsafe-inline' https://fonts.googleapis.com;` — `unsafe-inline` needed for Tailwind
  - `font-src 'self' https://fonts.gstatic.com;` — Google Fonts
  - `connect-src 'self' https://generativelanguage.googleapis.com;` — Gemini API (client-side SDK calls + validation)
  - `img-src 'self' data:;`
  - `frame-ancestors 'none';`
  - `base-uri 'self';`
  - `form-action 'self';`

Keep the entire CSP on a single line in the TOML value (TOML multi-line strings can be tricky with Netlify).

Do NOT modify any existing content in `netlify.toml` — only append the headers section.
</action>
<verify>
Run `cat netlify.toml` and verify: (1) all existing build/dev/functions/edge_functions/redirects sections are intact, (2) new `[[headers]]` section exists with `for = "/*"`, (3) CSP includes all required directives. Validate TOML syntax by checking no unclosed quotes or brackets.
</verify>
<done>
`netlify.toml` has security headers section with CSP, X-Frame-Options, X-Content-Type-Options, Referrer-Policy, HSTS, and Permissions-Policy. All existing configuration is preserved. Headers apply to all routes.
</done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with no errors
2. `services/cryptoService.ts` exists and exports: encryptApiKey, decryptApiKey, getOrCreatePassphrase, validateGeminiApiKey, hasStoredKey, clearStoredKey, getDecryptedKey
3. `netlify.toml` contains `[[headers]]` section with at least 7 security headers including Content-Security-Policy
4. No new npm dependencies added (check package.json is unchanged)
</verification>

<success_criteria>

- Crypto service compiles and exports all required functions
- Security headers are configured in netlify.toml for all routes
- Zero new npm dependencies
- Existing netlify.toml configuration is preserved
  </success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-01-SUMMARY.md`
</output>
