---
phase: 01-security-hardening
plan: 03
type: execute
wave: 2
depends_on: ["01-01", "01-02"]
files_modified:
  - components/Settings.tsx
  - services/geminiService.ts
  - App.tsx
  - vite.config.ts
autonomous: true

must_haves:
  truths:
    - "User can enter their Gemini API key via a Settings panel"
    - "API key is validated against Gemini API before being saved"
    - "Valid key is encrypted and stored in localStorage (not plaintext)"
    - "Invalid key shows a clear error message and is NOT stored"
    - "App uses the stored encrypted key for all Gemini API calls (no build-time key)"
    - "Build artifacts contain no API key (vite.config.ts define block cleaned)"
    - "User without a stored key sees a prompt to enter their key before transcription"
    - "User can clear their stored key from Settings"
  artifacts:
    - path: "components/Settings.tsx"
      provides: "API key entry form with validation feedback, key status display, clear key button"
      exports: ["default"]
    - path: "services/geminiService.ts"
      provides: "Gemini API integration using decrypted key from localStorage instead of build-time env var"
      exports: ["uploadFile", "generateTranscript"]
    - path: "App.tsx"
      provides: "Root component with Settings access and API key state awareness"
      contains: "Settings"
    - path: "vite.config.ts"
      provides: "Vite config with API key injection removed"
  key_links:
    - from: "components/Settings.tsx"
      to: "services/cryptoService.ts"
      via: "import { encryptApiKey, validateGeminiApiKey, getOrCreatePassphrase, hasStoredKey, clearStoredKey }"
      pattern: "import.*cryptoService"
    - from: "services/geminiService.ts"
      to: "services/cryptoService.ts"
      via: "import { getDecryptedKey }"
      pattern: "getDecryptedKey"
    - from: "services/geminiService.ts"
      to: "netlify/functions/gemini-upload.ts"
      via: "X-Gemini-Key header in upload fetch call"
      pattern: "X-Gemini-Key"
    - from: "App.tsx"
      to: "components/Settings.tsx"
      via: "Settings component rendered in header/modal"
      pattern: "Settings"
---

<objective>
Build the Settings UI for API key management and rewire the entire app to use BYOK instead of the embedded build-time key.

Purpose: This is the culminating plan that delivers the BYOK experience to users. It creates the Settings component, removes the embedded API key, and rewires geminiService.ts to decrypt and use the stored key. After this plan, the app is fully functional with user-provided keys and has zero embedded secrets.

Output: Working BYOK flow: Settings page -> validate -> encrypt -> store -> decrypt on use -> pass to SDK and server functions.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-security-hardening/01-RESEARCH.md

Prior plan outputs (READ these SUMMARYs before starting):
@.planning/phases/01-security-hardening/01-01-SUMMARY.md — cryptoService.ts exports and netlify.toml headers
@.planning/phases/01-security-hardening/01-02-SUMMARY.md — Server function changes (v2 format, X-Gemini-Key header, new endpoint path)

Key source files to reference:
@services/geminiService.ts — Must be rewired (currently uses process.env.API_KEY)
@services/cryptoService.ts — Created by Plan 01: provides encrypt/decrypt/validate/hasStoredKey/clearStoredKey/getDecryptedKey
@App.tsx — Root component, needs Settings access and key state awareness
@vite.config.ts — Must remove the define block that injects API keys
@types.ts — Shared types
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Settings component with API key entry, validation, and management</name>
  <files>components/Settings.tsx</files>
  <action>
Create `components/Settings.tsx` — a React component for BYOK API key management.

**Component: `Settings`**
Props interface:
```typescript
interface SettingsProps {
  onClose: () => void;
  onKeyChanged: () => void; // Callback to notify App that key state changed
}
```

**State:**
- `apiKey: string` — input field value (plaintext, only in memory during entry)
- `isValidating: boolean` — true while validation request is in flight
- `error: string | null` — validation/save error message
- `success: string | null` — success message after save
- `keyExists: boolean` — whether an encrypted key is already stored

**On mount (`useEffect`):**
- Check `hasStoredKey()` from cryptoService and set `keyExists`

**`handleSaveKey` async function:**
1. Trim the apiKey input. If empty, set error "Please enter an API key" and return.
2. Set `isValidating = true`, clear error and success.
3. Call `validateGeminiApiKey(apiKey)` from cryptoService.
4. If validation returns `{ valid: false, error }`, set error to the returned error message, set `isValidating = false`, return. Do NOT store the key.
5. If valid: call `getOrCreatePassphrase()`, then `encryptApiKey(apiKey, passphrase)`, then `localStorage.setItem("gemini_encrypted_key", encrypted)`.
6. Clear `apiKey` from state (security: don't hold plaintext longer than needed).
7. Set `keyExists = true`, set success message "API key saved successfully!", set `isValidating = false`.
8. Call `onKeyChanged()` to notify parent.

**`handleClearKey` function:**
1. Call `clearStoredKey()` from cryptoService.
2. Set `keyExists = false`, clear success, call `onKeyChanged()`.

**UI Layout (Tailwind CSS, matching existing app style):**
The component renders as a modal overlay or side panel. Use the existing app's design language (white bg, rounded-xl, shadow-md, indigo-600 accent color, slate text colors).

Structure:
```
Modal overlay (fixed inset-0, bg-black/50, z-50)
└── Modal content (centered, max-w-md, bg-white, rounded-xl, p-6)
    ├── Header: "Settings" title + close button (X icon)
    ├── Section: "Gemini API Key"
    │   ├── Description text: "Enter your own Gemini API key to use this app. Your key is encrypted and stored locally in your browser."
    │   ├── Link: "Get a key from Google AI Studio" -> https://aistudio.google.com/app/apikey (target="_blank", rel="noopener noreferrer")
    │   ├── If keyExists: Green status badge "Key configured" + "Clear Key" button (text-red-600)
    │   ├── Input: type="password", placeholder="Enter your Gemini API key...", value=apiKey, onChange
    │   ├── Error message (text-red-600, shown if error)
    │   ├── Success message (text-green-600, shown if success)
    │   └── Save button: "Validate & Save Key" (bg-indigo-600, disabled while isValidating, shows spinner text "Validating..." when active)
    └── Footer: Security note text (small, gray): "Your key is encrypted with AES-256-GCM and stored only in your browser. It is never sent to our servers."
```

**Styling details:**
- Use `font-sans` (Inter, matching the app)
- Input: `w-full px-4 py-2.5 border border-slate-300 rounded-lg focus:ring-2 focus:ring-indigo-500 focus:border-indigo-500`
- Save button: `w-full px-4 py-2.5 bg-indigo-600 text-white font-medium rounded-lg hover:bg-indigo-700 disabled:opacity-50 disabled:cursor-not-allowed`
- Clear key button: `text-sm text-red-600 hover:text-red-700 font-medium`
- Close button: top-right, `text-slate-400 hover:text-slate-600`

**Important:**
- The `apiKey` state holds plaintext ONLY while the user is typing. It's cleared after save.
- The input type is "password" so the key is masked.
- Follow existing component conventions: `React.FC<SettingsProps>`, default export, named imports from cryptoService.
  </action>
  <verify>
Run `npx tsc --noEmit` — no type errors. Read the file and verify: (1) imports from `../services/cryptoService`, (2) `validateGeminiApiKey` is called before saving, (3) `encryptApiKey` is called before localStorage.setItem, (4) `apiKey` state is cleared after successful save (`setApiKey("")`), (5) input type is "password", (6) error and success states are displayed, (7) "Clear Key" functionality calls `clearStoredKey()`.
  </verify>
  <done>
Settings component exists with: API key input (password type), validation before save, encryption before storage, clear key functionality, status display, proper error/success messaging, security note. Matches app design language.
  </done>
</task>

<task type="auto">
  <name>Task 2: Remove embedded API key and rewire geminiService.ts + App.tsx for BYOK</name>
  <files>services/geminiService.ts, App.tsx, vite.config.ts</files>
  <action>
This task removes the embedded API key and wires everything together for BYOK.

**Step 1: Clean vite.config.ts (SEC-04)**
Remove the `define` block from `vite.config.ts`:
```typescript
// REMOVE these lines:
define: {
  'process.env.API_KEY': JSON.stringify(env.GEMINI_API_KEY || ''),
  'process.env.GEMINI_API_KEY': JSON.stringify(env.GEMINI_API_KEY || '')
},
```
Also remove `loadEnv` from the Vite import since it's no longer needed (check if anything else uses it first — it's only used for the API key). Change to simple `defineConfig({...})` without the `({ mode })` wrapper if loadEnv was the only reason for the function form. However, keep the function form if the `mode` param might be useful later. Simplest approach: just remove the `define` block and keep everything else.

**Step 2: Rewire geminiService.ts**
Major changes to `services/geminiService.ts`:

a) **Remove the build-time API key singleton.** Replace the entire `getAI()` function:
```typescript
// REMOVE the old getAI singleton (lines 4-15)
// REPLACE with:
import { getDecryptedKey } from "./cryptoService";

const createAI = async (): Promise<GoogleGenAI> => {
  const apiKey = await getDecryptedKey();
  if (!apiKey) {
    throw new Error("No API key configured. Please add your Gemini API key in Settings.");
  }
  return new GoogleGenAI({ apiKey });
};
```
Note: `createAI` is async because `getDecryptedKey` decrypts from localStorage. The old `getAI()` was sync. This means callers need to await it.

b) **Update `uploadFile` function:**
The upload to `/.netlify/functions/gemini-upload` needs to pass the API key via header for BYOK support (matching Plan 02's server changes). Also update the endpoint path if Plan 02 changed it.

At the start of `uploadFile`:
```typescript
const apiKey = await getDecryptedKey();
if (!apiKey) {
  throw new Error("No API key configured. Please add your Gemini API key in Settings.");
}
```

In the POST fetch to the upload function, add the key header:
```typescript
const response = await fetch('/api/gemini-upload', {  // Updated path for v2 function
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    'X-Gemini-Key': apiKey,
  },
  body: JSON.stringify({
    name: file.name,
    size: file.size,
    mimeType: file.type
  })
});
```

Note the path change: Plan 02 migrated gemini-upload to v2 format with `path: "/api/gemini-upload"`. Update the fetch URL accordingly. **IMPORTANT:** Read the 01-02-SUMMARY.md to confirm the exact path the v2 function is configured on. If the summary says `/.netlify/functions/gemini-upload` still works, use that. If it says `/api/gemini-upload`, use that.

c) **Update `generateTranscript` function:**
Replace `const aiClient = getAI();` with `const aiClient = await createAI();` inside the loop. However, for efficiency, move the client creation OUTSIDE the while loop (create once, reuse):

```typescript
// At the start of generateTranscript, before the while loop:
const aiClient = await createAI();
```

Then remove `const aiClient = getAI();` from inside the loop (line ~208).

d) **Remove the old `ai` variable and `getAI` function entirely.** Remove lines 4-15.

e) **Remove `process.env.API_KEY` reference.** After removing getAI, grep the file for any remaining `process.env` references. There should be none.

**Step 3: Update App.tsx for Settings access and key awareness**

a) **Add Settings state and import:**
```typescript
import Settings from './components/Settings';
import { hasStoredKey } from './services/cryptoService';

// Inside the App component, add state:
const [showSettings, setShowSettings] = useState(false);
const [apiKeyConfigured, setApiKeyConfigured] = useState(false);

// On mount, check for stored key:
useEffect(() => {
  setApiKeyConfigured(hasStoredKey());
}, []);
```

Add `useEffect` to the React import: `import React, { useState, useEffect } from 'react';`

b) **Add Settings button to header:**
In the header (next to the existing "New Transcription" button area), add a settings gear icon button that's always visible:
```tsx
<button
  onClick={() => setShowSettings(true)}
  className="text-slate-500 hover:text-indigo-600 transition-colors p-2 rounded-lg hover:bg-slate-100"
  title="Settings"
>
  <svg className="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M10.325 4.317c.426-1.756 2.924-1.756 3.35 0a1.724 1.724 0 002.573 1.066c1.543-.94 3.31.826 2.37 2.37a1.724 1.724 0 001.066 2.573c1.756.426 1.756 2.924 0 3.35a1.724 1.724 0 00-1.066 2.573c.94 1.543-.826 3.31-2.37 2.37a1.724 1.724 0 00-2.573 1.066c-.426 1.756-2.924 1.756-3.35 0a1.724 1.724 0 00-2.573-1.066c-1.543.94-3.31-.826-2.37-2.37a1.724 1.724 0 00-1.066-2.573c-1.756-.426-1.756-2.924 0-3.35a1.724 1.724 0 001.066-2.573c-.94-1.543.826-3.31 2.37-2.37.996.608 2.296.07 2.572-1.065z" />
    <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z" />
  </svg>
</button>
```

Place this in the header's flex container, between the logo and the "New Transcription" button.

c) **Render Settings modal:**
At the bottom of the return JSX (inside the root div, after `</main>`):
```tsx
{showSettings && (
  <Settings
    onClose={() => setShowSettings(false)}
    onKeyChanged={() => setApiKeyConfigured(hasStoredKey())}
  />
)}
```

d) **Show API key prompt when no key is configured:**
When `!apiKeyConfigured` and user is in IDLE state (no file selected yet), show a prominent message instead of or above the hero section:
```tsx
{status === TranscriptionStatus.IDLE && !apiKeyConfigured && (
  <div className="w-full max-w-2xl mb-8 bg-amber-50 border border-amber-200 rounded-xl p-6 text-center animate-fade-in">
    <h3 className="text-lg font-semibold text-amber-900 mb-2">API Key Required</h3>
    <p className="text-amber-700 mb-4">To get started, you'll need to add your Gemini API key.</p>
    <button
      onClick={() => setShowSettings(true)}
      className="px-6 py-2.5 bg-indigo-600 rounded-lg text-white font-medium hover:bg-indigo-700 transition-all shadow-lg shadow-indigo-200"
    >
      Open Settings
    </button>
  </div>
)}
```

Place this BEFORE the file upload section. Also disable the "Generate Transcript" button when `!apiKeyConfigured` by adding a check in `handleStartTranscription`:
```typescript
if (!apiKeyConfigured) {
  setShowSettings(true);
  return;
}
```

e) **Update error handling:**
The error message from geminiService will now say "No API key configured. Please add your Gemini API key in Settings." when no key exists. This will display in the error UI naturally via the existing error handling.

**Step 4: Verify no remaining embedded key references**
After all changes, search the entire codebase for:
- `process.env.API_KEY` — should only exist in gemini-upload.ts fallback
- `process.env.GEMINI_API_KEY` — should only exist in gemini-upload.ts fallback
- `JSON.stringify(env.GEMINI_API_KEY` — should not exist anywhere

**Important notes:**
- The `createAI` function creates a new `GoogleGenAI` instance each time. This is intentional — the old singleton pattern broke if the key changed. Since `createAI` is only called once per `generateTranscript` invocation (before the loop), the overhead is negligible.
- The `uploadFile` function now gets the key independently because it needs to pass it to the server. This is a separate decryption from the one in `generateTranscript`, but both are fast.
  </action>
  <verify>
1. `npx tsc --noEmit` passes with no errors
2. `grep -r "process.env.API_KEY" --include="*.ts" --include="*.tsx"` — should only match gemini-upload.ts fallback, NOT vite.config.ts or geminiService.ts
3. `grep -r "JSON.stringify(env.GEMINI" vite.config.ts` — should return no matches
4. Read App.tsx and verify: Settings import, showSettings state, gear icon button in header, Settings modal rendering, apiKeyConfigured state, API key prompt for unconfigured state
5. Read geminiService.ts and verify: imports from cryptoService, `createAI` async function replaces `getAI`, `X-Gemini-Key` header in upload fetch, no `process.env.API_KEY` reference
6. Read vite.config.ts and verify: no `define` block with API keys
7. `npm run build` succeeds (the build should work without the env var since it's no longer injected)
  </verify>
  <done>
Complete BYOK flow is operational: (1) Settings component in App.tsx allows key entry/validation/storage/clearing, (2) geminiService.ts decrypts stored key for SDK initialization and passes it to server function via header, (3) vite.config.ts has no embedded API key, (4) Users without a key see a clear prompt to configure one, (5) Build artifacts contain zero API keys.
  </done>
</task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes
2. `npm run build` succeeds without GEMINI_API_KEY env var
3. `grep -rn "process.env.API_KEY\|process.env.GEMINI_API_KEY" --include="*.ts" --include="*.tsx" .` — only in gemini-upload.ts fallback
4. `grep -n "JSON.stringify(env.GEMINI" vite.config.ts` — zero matches
5. Settings component renders, accepts key input, validates, encrypts, stores
6. geminiService.ts uses `getDecryptedKey()` from cryptoService (not process.env)
7. Upload fetch includes `X-Gemini-Key` header
8. App shows "API Key Required" prompt when no key is stored
9. App shows gear icon for Settings access in header
</verification>

<success_criteria>
- User can enter, validate, and save their Gemini API key via Settings UI
- API key is encrypted (AES-GCM) in localStorage, never stored in plaintext
- Invalid keys are rejected with clear error message
- Build artifacts contain zero API keys (vite define block removed)
- App uses stored key for all API calls (SDK + server function header)
- Users without a key see a clear prompt before they can transcribe
- Users can clear their stored key
</success_criteria>

<output>
After completion, create `.planning/phases/01-security-hardening/01-03-SUMMARY.md`
</output>
