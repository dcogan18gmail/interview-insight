---
phase: 05-multi-project-dashboard
plan: 02
type: execute
wave: 2
depends_on: ['05-01']
files_modified:
  - src/features/dashboard/components/Sidebar.tsx
  - src/features/dashboard/components/ProjectEntry.tsx
  - src/features/dashboard/components/ConfirmDialog.tsx
  - src/features/project/ProjectPage.tsx
  - src/contexts/ProjectsContext.tsx
autonomous: true

must_haves:
  truths:
    - 'User can double-click a project name in the sidebar to enter inline edit mode, Enter saves, Escape cancels'
    - 'User can open a three-dot menu on each project entry in the sidebar to access delete'
    - 'User sees a confirmation dialog before a project is deleted'
    - 'User can create a new project which persists to storage with status updates through the transcription flow'
    - 'User can navigate to an existing project and see it load from storage'
    - 'Navigating to a deleted/nonexistent project redirects to dashboard'
  artifacts:
    - path: 'src/features/dashboard/components/ProjectEntry.tsx'
      provides: 'Sidebar project entry with inline rename (double-click) and three-dot menu'
      contains: 'onDoubleClick'
    - path: 'src/features/dashboard/components/ConfirmDialog.tsx'
      provides: 'Reusable confirmation dialog using native <dialog> with showModal()'
      contains: 'showModal'
    - path: 'src/features/project/ProjectPage.tsx'
      provides: 'Project creation wired to storage, existing project loading from storage'
      contains: 'createProject'
  key_links:
    - from: 'src/features/dashboard/components/ProjectEntry.tsx'
      to: 'src/contexts/ProjectsContext.tsx'
      via: 'updateProject for rename, removeProject for delete'
      pattern: 'updateProject|removeProject'
    - from: 'src/features/project/ProjectPage.tsx'
      to: 'src/contexts/ProjectsContext.tsx'
      via: 'createProject to persist new project on transcription start'
      pattern: 'createProject'
    - from: 'src/features/dashboard/components/ConfirmDialog.tsx'
      to: 'native dialog element'
      via: 'useRef + showModal() imperative API'
      pattern: 'dialogRef.*showModal'
---

<objective>
Implement sidebar CRUD interactions (inline rename via double-click, delete via three-dot menu with confirmation dialog) and wire the project creation flow to persist projects in storage throughout the transcription lifecycle.

Purpose: Delivers PROJ-02 (create), PROJ-03 (rename), and PROJ-04 (delete) -- the core CRUD operations that make the dashboard functional.
Output: Interactive sidebar with rename/delete, ConfirmDialog component, project creation persisted to storage, existing project loading.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-multi-project-dashboard/05-CONTEXT.md
@.planning/phases/05-multi-project-dashboard/05-RESEARCH.md
@.planning/phases/05-multi-project-dashboard/05-01-SUMMARY.md
@src/features/dashboard/components/Sidebar.tsx
@src/features/project/ProjectPage.tsx
@src/contexts/ProjectsContext.tsx
@src/features/project/hooks/useTranscription.ts
@src/services/storageService.ts
@src/services/storageService.types.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Sidebar project entry with inline rename and three-dot delete menu</name>
  <files>
    src/features/dashboard/components/ProjectEntry.tsx
    src/features/dashboard/components/ConfirmDialog.tsx
    src/features/dashboard/components/Sidebar.tsx
  </files>
  <action>
**Create `ConfirmDialog.tsx`:**

A reusable confirmation dialog using the native HTML `<dialog>` element with `showModal()` for proper focus trapping, backdrop, and Escape handling. Per RESEARCH.md Pattern 1.

Props interface:

```typescript
interface ConfirmDialogProps {
  open: boolean;
  title: string;
  message: string;
  confirmLabel?: string; // default: "Confirm"
  cancelLabel?: string; // default: "Cancel"
  onConfirm: () => void;
  onCancel: () => void;
  variant?: 'danger' | 'default'; // danger = red confirm button
}
```

Implementation requirements:

- Use `useRef<HTMLDialogElement>` and `useEffect` to call `showModal()` when `open` becomes true and `close()` when it becomes false.
- NEVER set the `open` attribute directly on `<dialog>` in JSX (this bypasses focus trap).
- Handle the `cancel` event on `<dialog>` (fires on Escape key) by calling `onCancel`.
- Style the dialog with Tailwind: `rounded-xl border-0 p-0 shadow-xl backdrop:bg-black/50`.
- The confirm button uses `bg-red-600 hover:bg-red-700 text-white` for `variant="danger"`, and `bg-indigo-600 hover:bg-indigo-700 text-white` for default.
- Cancel button: `border border-slate-300 bg-white text-slate-700 hover:bg-slate-50`.
- Both buttons should have `rounded-lg px-4 py-2 text-sm font-medium transition-colors`.
- The dialog content container: `w-80 p-6`.

**Create `ProjectEntry.tsx`:**

An individual project entry in the sidebar with three interactions:

1. **Click:** Navigate to `/project/:id`
2. **Double-click:** Enter inline rename mode (per LOCKED decision)
3. **Three-dot menu:** Opens a small dropdown with "Delete" option (per LOCKED decision)

Props:

```typescript
interface ProjectEntryProps {
  project: ProjectMetadata;
  isSelected: boolean;
}
```

**Inline rename (double-click to edit):**

- Track local `editing` state (boolean) and `draft` state (string).
- On double-click of the project name: set `editing = true`, `draft = project.name`.
- When editing, render an `<input>` instead of the name text.
- Use `useRef<HTMLInputElement>` and `useEffect` to focus + select the input when editing starts.
- Enter key: trim draft, validate non-empty, call `updateProject({...project, name: trimmed})` from `useProjects()`, exit editing.
- Escape key: revert `draft` to `project.name`, exit editing.
- Blur: save (same as Enter logic) -- prevents data loss from clicking away.
- If trimmed draft is empty, revert to original name (don't save empty string).
- Add `aria-label="Project name"` to the input.

**Three-dot menu:**

- Small button with three vertical dots (ellipsis icon) positioned at the right of the entry.
- Only visible on hover of the entry OR when the menu is open.
- Clicking the three-dot button opens a small dropdown positioned below the button.
- The dropdown has one option: "Delete" (with a trash icon and red text).
- Clicking "Delete" opens the ConfirmDialog.
- Click outside the dropdown or press Escape closes it.
- Use `e.stopPropagation()` on the three-dot button click to prevent navigating to the project.

**Delete confirmation:**

- Track `confirmDelete` state (boolean).
- ConfirmDialog with variant="danger", title="Delete Project", message="Are you sure you want to delete '[project.name]'? This cannot be undone.", confirmLabel="Delete".
- On confirm: call `removeProject(project.id)` from `useProjects()`. If the deleted project was selected (in URL), navigate to `/`.
- On cancel: close dialog.

**Single-click vs double-click disambiguation:**

- Use a small timeout approach: on single click, set a timer (250ms). If no second click arrives, navigate. If a second click arrives within 250ms, cancel the timer and enter edit mode.
- Alternatively, make the name area the double-click target and the rest of the entry the single-click navigation target. This is simpler -- the project name `<span>` gets `onDoubleClick` for rename, and the outer `<button>` gets `onClick` for navigation. The `onDoubleClick` handler calls `e.stopPropagation()` to prevent navigation.

Recommended approach: Make the entry a clickable container for navigation. The project name within it captures double-click for rename. The three-dot button captures click for the menu. Both use `stopPropagation`.

**Update `Sidebar.tsx`:**

Replace the inline project list rendering with `<ProjectEntry>` components:

```tsx
{
  sortedProjects.map((project) => (
    <ProjectEntry
      key={project.id}
      project={project}
      isSelected={project.id === projectId}
    />
  ));
}
```

Also add an empty state when there are zero projects and the sidebar is expanded:

```tsx
{
  sortedProjects.length === 0 && !collapsed && (
    <div className="px-3 py-8 text-center text-xs text-slate-400">
      No projects yet
    </div>
  );
}
```

  </action>
  <verify>
1. `npx tsc --noEmit` -- zero errors.
2. `npm run lint` -- no lint errors.
3. Manual testing:
   - Double-click a project name in sidebar -> input appears, pre-filled and selected.
   - Type new name, press Enter -> name updates in sidebar.
   - Double-click, press Escape -> reverts to original name.
   - Double-click, clear field, press Enter -> reverts to original name (no empty save).
   - Hover over project entry -> three-dot button appears.
   - Click three-dot -> dropdown with "Delete" appears.
   - Click "Delete" -> confirmation dialog opens with project name.
   - Click "Cancel" in dialog -> dialog closes, project remains.
   - Click "Delete" in dialog -> project removed from sidebar.
   - Press Escape while dialog is open -> dialog closes.
  </verify>
  <done>
ProjectEntry component renders in sidebar with: (a) click to navigate, (b) double-click to inline rename with Enter/Escape/blur handling, (c) three-dot menu with delete option. ConfirmDialog component uses native dialog with showModal() for proper focus trap and backdrop. Empty string rename is prevented.
  </done>
</task>

<task type="auto">
  <name>Task 2: Wire project creation flow to storage and load existing projects</name>
  <files>
    src/features/project/ProjectPage.tsx
    src/contexts/ProjectsContext.tsx
  </files>
  <action>
**Update `ProjectPage.tsx` to persist projects through the transcription lifecycle:**

Currently, ProjectPage runs the transcription flow but never persists to storage. This task wires the flow so that:

1. **On transcription start:** Create a project in storage immediately (so it appears in the sidebar with status 'uploading'). Store the created project ID in local state.

2. **Update status through the flow:** Update project status to 'processing' when upload completes, and 'completed' when transcription finishes.

3. **Save transcript on completion:** Call `saveTranscript` from storageService to persist the transcript data.

4. **Navigate to the persisted project:** After creation, replace the URL from `/project/new` to `/project/:createdId` so the sidebar highlights correctly and the URL is bookmarkable.

Implementation:

```tsx
import { useState, useEffect } from 'react';
import { useParams, useNavigate } from 'react-router';
import { useTranscription } from '@/features/project/hooks/useTranscription';
import { useSettings } from '@/contexts/SettingsContext';
import { useProjects } from '@/contexts/ProjectsContext';
import { saveTranscript } from '@/services/storageService';
import FileUpload from '@/features/project/components/FileUpload';
import LoadingState from '@/features/project/components/LoadingState';
import TranscriptView from '@/features/project/components/TranscriptView';
import { FileData, TranscriptionStatus } from '@/types';

export default function ProjectPage() {
  const { projectId } = useParams();
  const navigate = useNavigate();
  const { state: settingsState } = useSettings();
  const { machineState, startTranscription, reset } = useTranscription();
  const { state: projectsState, createProject, updateProject } = useProjects();

  const isNew = projectId === 'new';

  // Track the created project ID for the new project flow
  const [createdProjectId, setCreatedProjectId] = useState<string | null>(null);

  // --- Existing project loading ---
  const existingProject =
    !isNew && projectId
      ? (projectsState.projects.find((p) => p.id === projectId) ?? null)
      : null;

  // Redirect if existing project not found (after initialization)
  useEffect(() => {
    if (!isNew && projectId && projectsState.initialized && !existingProject) {
      navigate('/', { replace: true });
    }
  }, [isNew, projectId, projectsState.initialized, existingProject, navigate]);

  // --- New project: handle file selection and start transcription ---
  const handleFileSelected = (fileData: FileData) => {
    if (!fileData.file) return;
    if (!settingsState.apiKeyConfigured) {
      navigate('/settings');
      return;
    }

    // Create project in storage immediately
    const fileInfo = {
      name: fileData.name,
      type: fileData.type,
      size: fileData.size,
      duration: fileData.duration,
    };
    const { project, ok } = createProject(fileData.name, fileInfo);
    if (ok) {
      setCreatedProjectId(project.id);
      // Navigate to the new project's URL so sidebar highlights it
      navigate(`/project/${project.id}`, { replace: true });
    }

    startTranscription(fileData.file, fileData.type, fileData.duration);
  };

  // --- Update project status through transcription lifecycle ---
  useEffect(() => {
    const targetId = createdProjectId;
    if (!targetId) return;

    const project = projectsState.projects.find((p) => p.id === targetId);
    if (!project) return;

    if (machineState.state === 'uploading' && project.status !== 'uploading') {
      updateProject({ ...project, status: 'uploading' });
    } else if (
      machineState.state === 'processing' &&
      project.status !== 'processing'
    ) {
      updateProject({ ...project, status: 'processing' });
    } else if (
      machineState.state === 'completed' &&
      project.status !== 'completed'
    ) {
      // Save transcript data
      saveTranscript({
        projectId: targetId,
        segments: machineState.transcript,
        completedAt: new Date().toISOString(),
      });
      updateProject({ ...project, status: 'completed' });
    } else if (machineState.state === 'error' && project.status !== 'error') {
      updateProject({ ...project, status: 'error' });
    }
  }, [
    machineState.state,
    createdProjectId,
    projectsState.projects,
    updateProject,
    machineState.transcript,
  ]);

  const handleReset = () => {
    reset();
    setCreatedProjectId(null);
    navigate('/project/new', { replace: true });
  };

  // Map hook state names to TranscriptionStatus enum for LoadingState
  const statusMap: Record<string, TranscriptionStatus> = {
    idle: TranscriptionStatus.IDLE,
    uploading: TranscriptionStatus.UPLOADING,
    processing: TranscriptionStatus.PROCESSING,
    completed: TranscriptionStatus.COMPLETED,
    error: TranscriptionStatus.ERROR,
  };
  const displayStatus =
    statusMap[machineState.state] ?? TranscriptionStatus.IDLE;

  // --- Render for existing project (non-new, non-creating) ---
  if (!isNew && existingProject && !createdProjectId) {
    // Existing project loaded from storage -- show transcript if available
    // This is a read-only view for now; transcript loading happens in Plan 03
    return (
      <div className="p-8">
        <h2 className="text-xl font-bold text-slate-800">
          {existingProject.name}
        </h2>
        <p className="mt-2 text-sm text-slate-500">
          Status: {existingProject.status} &middot;{' '}
          {existingProject.segmentCount} segments
        </p>
        {/* Full transcript display will be implemented in Plan 03 */}
      </div>
    );
  }

  // --- Render for new/in-progress project ---
  return (
    <div className="flex flex-col items-center">
      {/* API Key Required Prompt */}
      {machineState.state === 'idle' && !settingsState.apiKeyConfigured && (
        <div className="animate-fade-in mb-8 w-full max-w-2xl rounded-xl border border-amber-200 bg-amber-50 p-6 text-center">
          <h3 className="mb-2 text-lg font-semibold text-amber-900">
            API Key Required
          </h3>
          <p className="mb-4 text-amber-700">
            To get started, you&apos;ll need to add your Gemini API key.
          </p>
          <button
            onClick={() => navigate('/settings')}
            className="rounded-lg bg-indigo-600 px-6 py-2.5 font-medium text-white shadow-lg shadow-indigo-200 transition-all hover:bg-indigo-700"
          >
            Open Settings
          </button>
        </div>
      )}

      {/* File Upload Stage */}
      {machineState.state === 'idle' && (
        <div className="animate-fade-in w-full max-w-2xl">
          <FileUpload onFileSelected={handleFileSelected} disabled={false} />
        </div>
      )}

      {/* Processing Stage */}
      {(machineState.state === 'uploading' ||
        machineState.state === 'processing') && (
        <LoadingState
          progress={machineState.progress}
          currentSegment={machineState.currentSegment}
          status={displayStatus}
        />
      )}

      {/* Error Stage */}
      {machineState.state === 'error' && (
        <div className="animate-fade-in w-full max-w-2xl rounded-xl border border-red-100 bg-red-50 p-8 text-center">
          <div className="mx-auto mb-4 flex h-16 w-16 items-center justify-center rounded-full bg-red-100">
            <svg
              className="h-8 w-8 text-red-500"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth="2"
                d="M12 9v2m0 4h.01m-6.938 4h13.856c1.54 0 2.502-1.667 1.732-3L13.732 4c-.77-1.333-2.694-1.333-3.464 0L3.34 16c-.77 1.333.192 3 1.732 3z"
              />
            </svg>
          </div>
          <h3 className="mb-2 text-lg font-semibold text-gray-900">
            Processing Failed
          </h3>
          <p className="mb-6 text-gray-600">
            {machineState.error ?? 'Something went wrong.'}
          </p>
          <button
            onClick={handleReset}
            className="rounded-lg border border-gray-300 bg-white px-6 py-2 font-medium text-gray-700 transition-colors hover:bg-gray-50"
          >
            Try Again
          </button>
        </div>
      )}

      {/* Results Stage */}
      {machineState.state === 'completed' && (
        <div className="w-full">
          <div className="mb-4 flex justify-end">
            <button
              onClick={handleReset}
              className="flex items-center text-sm font-medium text-slate-600 transition-colors hover:text-indigo-600"
            >
              <svg
                className="mr-1 h-4 w-4"
                fill="none"
                stroke="currentColor"
                viewBox="0 0 24 24"
              >
                <path
                  strokeLinecap="round"
                  strokeLinejoin="round"
                  strokeWidth="2"
                  d="M12 4v16m8-8H4"
                />
              </svg>
              New Transcription
            </button>
          </div>
          <TranscriptView transcript={machineState.transcript} />
        </div>
      )}
    </div>
  );
}
```

**Key implementation notes:**

- The `createdProjectId` state tracks the newly created project. This is needed to update its status through the lifecycle without re-rendering loops.
- The `useEffect` for status updates uses the project's current status as a guard to prevent infinite update loops.
- `saveTranscript` is called directly from storageService (not through context) because context does not expose transcript operations -- it only manages project metadata.
- When the user clicks "Try Again" after an error, `handleReset` clears the created project ID and navigates back to `/project/new`.
- For existing projects navigated to directly, the component checks if the project exists in context. If not (and context is initialized), it redirects to `/`.

**Optional: Add `getTranscript` to ProjectsContext or leave as direct storageService call.**

For this plan, leave transcript loading as a direct `getTranscript()` call from storageService. The context manages metadata only. Plan 03 will integrate transcript display.
</action>
<verify>

1. `npx tsc --noEmit` -- zero errors.
2. `npm run lint` -- no lint errors.
3. Manual testing:
   - Navigate to `/project/new`, select a file, observe project appears in sidebar immediately with uploading status.
   - Watch status update from uploading -> processing -> completed in sidebar.
   - After completion, the transcript is visible and the URL is `/project/:createdId`.
   - Navigate back to `/`, then click the project in sidebar -> loads project view.
   - Navigate to `/project/nonexistent-uuid` -> redirects to `/`.
   - After transcription error, click "Try Again" -> returns to upload state.
     </verify>
     <done>
     Sidebar entries have interactive rename (double-click, Enter/Escape/blur) and delete (three-dot menu -> confirmation dialog). ConfirmDialog uses native dialog showModal(). Project creation flow persists to storage immediately on upload start, updates status through lifecycle, saves transcript on completion. Existing projects load from storage. Nonexistent project URLs redirect to dashboard.
     </done>
     </task>

</tasks>

<verification>
1. `npx tsc --noEmit` passes with zero errors
2. `npm run lint` passes
3. Double-click rename works: enter edit, save on Enter, cancel on Escape, save on blur
4. Empty rename reverts to original name
5. Three-dot menu appears on project entries with "Delete" option
6. Delete shows ConfirmDialog (modal with backdrop, focus trap, Escape to close)
7. Confirming delete removes project from sidebar and storage
8. New transcription creates project in storage immediately (visible in sidebar)
9. Project status updates through uploading -> processing -> completed
10. Transcript data persisted to localStorage on completion
11. Navigating to nonexistent project redirects to /
</verification>

<success_criteria>

- All four CRUD operations work: Create (persisted on upload start), Read (existing project loads), Update (rename persists), Delete (with confirmation)
- Inline rename follows the double-click pattern with Enter/Escape/blur keyboard support
- Delete uses three-dot menu (not direct button) per LOCKED decision
- ConfirmDialog uses native <dialog> showModal() (not open attribute)
- No regressions in existing transcription flow
  </success_criteria>

<output>
After completion, create `.planning/phases/05-multi-project-dashboard/05-02-SUMMARY.md`
</output>
