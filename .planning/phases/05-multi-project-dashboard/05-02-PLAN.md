---
phase: 05-multi-project-dashboard
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/features/project/ProjectPage.tsx
autonomous: true

must_haves:
  truths:
    - 'User can create a new project by uploading a file, and it appears in the dashboard after transcription starts'
    - 'Transcription results are persisted to localStorage and survive page refresh'
    - 'User can navigate to an existing project and see its completed transcript'
    - 'Navigating to a deleted or non-existent project redirects to the dashboard'
    - 'After transcription completes, the URL updates from /project/new to /project/:realId'
  artifacts:
    - path: 'src/features/project/ProjectPage.tsx'
      provides: 'Full project page handling both new transcription and existing project loading'
      exports: ['default']
  key_links:
    - from: 'src/features/project/ProjectPage.tsx'
      to: 'ProjectsContext'
      via: 'useProjects().createProject to persist new project, state.projects to load existing'
      pattern: "useProjects\\(\\)"
    - from: 'src/features/project/ProjectPage.tsx'
      to: 'storageService'
      via: 'getTranscript() to load existing transcript, saveTranscript() to persist results'
      pattern: '(getTranscript|saveTranscript)'
    - from: 'src/features/project/ProjectPage.tsx'
      to: 'useTranscription hook'
      via: "machineState.state === 'completed' triggers project creation and transcript save"
      pattern: "machineState\\.state"
---

<objective>
Wire the project creation flow so transcription results persist to storage, and enable loading existing projects with their transcripts.

Purpose: Fulfills PROJ-02 (create new project triggers upload flow) and closes the critical gap identified in research -- transcription results are currently not persisted, and existing projects cannot be loaded. Without this plan, projects appear in the dashboard but clicking them shows nothing.

Output: Enhanced ProjectPage.tsx that handles both the "new project" flow (create + persist) and the "existing project" flow (load transcript from storage).
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md

# Phase 5 research (wiring patterns, pitfalls, code examples)

@.planning/phases/05-multi-project-dashboard/05-RESEARCH.md

# Current ProjectPage (only handles "new" case)

@src/features/project/ProjectPage.tsx

# useTranscription hook (state machine with machineState)

@src/features/project/hooks/useTranscription.ts

# ProjectsContext (createProject, updateProject, removeProject)

@src/contexts/ProjectsContext.tsx

# Storage service (getTranscript, saveTranscript)

@src/services/storageService.ts

# Storage types (ProjectMetadata, TranscriptData, FileInfo)

@src/services/storageService.types.ts

# Shared types (FileData, TranscriptSegment)

@src/types/index.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Wire new project creation to storage on transcription start</name>
  <files>
    src/features/project/ProjectPage.tsx
  </files>
  <action>
Enhance `ProjectPage.tsx` to create a project in storage when transcription begins and persist the transcript when it completes.

**New imports:**

- `{ useEffect, useRef }` from React (useRef to track if project was already created to avoid double-creation in StrictMode)
- `{ useProjects }` from `@/contexts/ProjectsContext`
- `{ getTranscript, saveTranscript }` from `@/services/storageService`
- `type { FileInfo }` from `@/services/storageService.types`

**Remove** the `const _ = isNew;` placeholder line.

**Add state for tracking the created project ID:**

- `const createdProjectIdRef = useRef<string | null>(null);` -- tracks the project ID created during this session's new transcription flow. Using a ref (not state) because we don't want to trigger re-renders.

**Modify `handleFileSelected`:**
When `isNew` and the user selects a file:

1. Build a `FileInfo` object from the `FileData`: `{ name: fileData.name, type: fileData.type, size: fileData.size, duration: fileData.duration }`
2. Call `createProject(fileData.name, fileInfo)` from `useProjects()`
3. If `ok` is true, store the project ID: `createdProjectIdRef.current = project.id`
4. Call `updateProject({ ...project, status: 'uploading' })` to set the initial status
5. Then proceed with `startTranscription(...)` as before

**Add useEffect to persist transcript on completion:**

```typescript
useEffect(() => {
  if (machineState.state === 'completed' && createdProjectIdRef.current) {
    const projectId = createdProjectIdRef.current;

    // Save transcript to storage
    saveTranscript({
      projectId,
      segments: machineState.transcript,
      completedAt: new Date().toISOString(),
    });

    // Update project status to completed
    const project = state.projects.find((p) => p.id === projectId);
    if (project) {
      updateProject({
        ...project,
        status: 'completed',
        segmentCount: machineState.transcript.length,
        updatedAt: new Date().toISOString(),
      });
    }

    // Navigate to the real project URL (replace /project/new in history)
    navigate(`/project/${projectId}`, { replace: true });
    createdProjectIdRef.current = null;
  }
}, [
  machineState.state,
  machineState.transcript,
  navigate,
  state.projects,
  updateProject,
]);
```

**Add useEffect to update project status on error:**

```typescript
useEffect(() => {
  if (machineState.state === 'error' && createdProjectIdRef.current) {
    const projectId = createdProjectIdRef.current;
    const project = state.projects.find((p) => p.id === projectId);
    if (project) {
      updateProject({
        ...project,
        status: 'error',
        updatedAt: new Date().toISOString(),
      });
    }
  }
}, [machineState.state, state.projects, updateProject]);
```

**Add useEffect to update status to 'processing' on upload complete:**

```typescript
useEffect(() => {
  if (machineState.state === 'processing' && createdProjectIdRef.current) {
    const projectId = createdProjectIdRef.current;
    const project = state.projects.find((p) => p.id === projectId);
    if (project && project.status !== 'processing') {
      updateProject({
        ...project,
        status: 'processing',
        updatedAt: new Date().toISOString(),
      });
    }
  }
}, [machineState.state, state.projects, updateProject]);
```

Note: These three effects can be combined into a single useEffect that switches on `machineState.state` to reduce effect count. Use your judgment on readability vs effect count. A single combined effect is preferred.
</action>
<verify>

- `npx tsc --noEmit` passes with zero errors
- `npx eslint src/features/project/ProjectPage.tsx` passes
  </verify>
  <done>
- New transcription creates a project in storage immediately when the user selects a file
- Project status updates through uploading -> processing -> completed/error lifecycle
- Transcript is saved to localStorage when transcription completes
- URL changes from /project/new to /project/:id after completion
- No double-creation in React StrictMode (useRef guard)
  </done>
  </task>

<task type="auto">
  <name>Task 2: Load existing project transcript and handle project-not-found</name>
  <files>
    src/features/project/ProjectPage.tsx
  </files>
  <action>
Add logic to `ProjectPage.tsx` to load and display an existing project's transcript when navigating to `/project/:id` (where id is not "new").

**Existing project lookup:**

```typescript
const { state, createProject, updateProject } = useProjects();

// Find existing project by ID
const existingProject = !isNew
  ? (state.projects.find((p) => p.id === projectId) ?? null)
  : null;
```

**Project-not-found redirect:**
Add a `useEffect` that redirects to the dashboard if the project doesn't exist:

```typescript
useEffect(() => {
  if (!isNew && state.initialized && !existingProject) {
    navigate('/', { replace: true });
  }
}, [isNew, state.initialized, existingProject, navigate]);
```

**Load transcript for existing project:**

```typescript
// Load transcript data from storage (only for existing projects)
const existingTranscript = existingProject
  ? getTranscript(existingProject.id)
  : null;
```

**Render logic update:**
The current render logic is entirely based on `machineState.state`. For existing projects, we need to show the transcript from storage instead.

Add conditional rendering BEFORE the existing machineState-based rendering:

```typescript
// Existing project with completed transcript
if (existingProject && existingTranscript && existingProject.status === 'completed') {
  return (
    <div className="flex flex-col items-center">
      <div className="w-full">
        <div className="mb-4 flex items-center justify-between">
          <h2 className="text-lg font-semibold text-slate-800 truncate">
            {existingProject.name}
          </h2>
          <button
            onClick={() => navigate('/project/new')}
            className="flex items-center text-sm font-medium text-slate-600 transition-colors hover:text-indigo-600"
          >
            <svg className="mr-1 h-4 w-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path strokeLinecap="round" strokeLinejoin="round" strokeWidth="2" d="M12 4v16m8-8H4"></path>
            </svg>
            New Transcription
          </button>
        </div>
        <TranscriptView transcript={existingTranscript.segments} />
      </div>
    </div>
  );
}

// Existing project with error status (allow retry by showing upload)
if (existingProject && existingProject.status === 'error' && machineState.state === 'idle') {
  return (
    <div className="flex flex-col items-center">
      <div className="animate-fade-in mb-8 w-full max-w-2xl rounded-xl border border-amber-200 bg-amber-50 p-6 text-center">
        <h3 className="mb-2 text-lg font-semibold text-amber-900">
          Previous transcription failed
        </h3>
        <p className="mb-4 text-amber-700">
          Upload the file again to retry transcription for this project.
        </p>
      </div>
      <div className="animate-fade-in w-full max-w-2xl">
        <FileUpload onFileSelected={handleFileSelected} disabled={false} />
      </div>
    </div>
  );
}

// Existing project still in progress (show loading state from project metadata)
if (existingProject && (existingProject.status === 'uploading' || existingProject.status === 'processing') && machineState.state === 'idle') {
  // Project was in progress but we refreshed -- show idle state so user can retry
  return (
    <div className="flex flex-col items-center">
      <div className="animate-fade-in mb-8 w-full max-w-2xl rounded-xl border border-amber-200 bg-amber-50 p-6 text-center">
        <h3 className="mb-2 text-lg font-semibold text-amber-900">
          Transcription was interrupted
        </h3>
        <p className="mb-4 text-amber-700">
          Upload the file again to restart transcription.
        </p>
      </div>
      <div className="animate-fade-in w-full max-w-2xl">
        <FileUpload onFileSelected={handleFileSelected} disabled={false} />
      </div>
    </div>
  );
}
```

Then the existing machineState-based rendering continues as the fallback for the "new" flow and active transcription states.

**Update handleFileSelected for existing project retry:**
When `!isNew` and the user selects a file (retry scenario), use the existing project ID instead of creating a new one:

```typescript
if (!isNew && existingProject) {
  createdProjectIdRef.current = existingProject.id;
  updateProject({
    ...existingProject,
    status: 'uploading',
    updatedAt: new Date().toISOString(),
  });
}
```

**Ensure handleReset for existing projects navigates back to dashboard:**
When on an existing project page and the user clicks "New Transcription" after completion, navigate to `/project/new` instead of just resetting state.
</action>
<verify>

- `npx tsc --noEmit` passes with zero errors
- `npx eslint src/features/project/ProjectPage.tsx` passes
- `npm run build` succeeds
  </verify>
  <done>
- Navigating to /project/:id loads the project from context and its transcript from storage
- Completed projects show TranscriptView with their persisted segments
- Non-existent project IDs redirect to the dashboard
- Error/interrupted projects show a retry upload interface
- Existing project retry reuses the project ID instead of creating a new one
- Zero TypeScript errors, zero ESLint errors, build passes
  </done>
  </task>

</tasks>

<verification>
1. `npm run build` passes with zero errors
2. `npx tsc --noEmit` reports zero type errors
3. `npx eslint src/features/project/ProjectPage.tsx` passes
4. ProjectPage.tsx handles three modes: new transcription, existing completed project, existing error/interrupted project
5. createProject is called before startTranscription (project appears in dashboard immediately)
6. saveTranscript is called when transcription completes
7. URL changes from /project/new to /project/:id after completion
8. Non-existent project IDs redirect to /
</verification>

<success_criteria>

- New transcription flow: file select -> createProject -> uploading -> processing -> completed -> transcript saved -> URL updated
- Existing completed project: shows project name + TranscriptView with persisted segments
- Existing error/interrupted project: shows retry message + FileUpload
- Non-existent project: redirect to dashboard
- Project status synced to storage throughout transcription lifecycle
- Transcript data persists in localStorage across page refresh
- Zero TypeScript errors, zero ESLint errors, build passes
  </success_criteria>

<output>
After completion, create `.planning/phases/05-multi-project-dashboard/05-02-SUMMARY.md`
</output>
