---
phase: 04-core-architecture-refactor
plan: 03
type: execute
wave: 3
depends_on: ['04-01', '04-02']
files_modified:
  - src/app/App.tsx
  - src/app/Layout.tsx
  - src/features/dashboard/DashboardPage.tsx
  - src/features/project/ProjectPage.tsx
  - src/features/settings/SettingsPage.tsx
  - src/features/settings/components/ApiKeyForm.tsx
  - src/index.tsx
autonomous: true

must_haves:
  truths:
    - 'React Router provides navigation between dashboard (/), project detail (/project/:projectId), and settings (/settings)'
    - 'Layout component renders shared header with navigation links and Outlet for child routes'
    - 'ProjectPage composes FileUpload, LoadingState, TranscriptView using the useTranscription hook'
    - 'SettingsPage renders as a full route (not just a modal overlay)'
    - 'DashboardPage exists as a placeholder with project list from ProjectsContext'
    - 'No prop drilling -- page components get state from contexts'
    - 'App.tsx is under 50 lines (just providers + router definition)'
    - 'Old monolithic App.tsx logic is fully decomposed into page components'
  artifacts:
    - path: 'src/app/App.tsx'
      provides: 'Router definition with providers'
      contains: 'BrowserRouter'
      min_lines: 20
    - path: 'src/app/Layout.tsx'
      provides: 'Shared header and Outlet'
      contains: 'Outlet'
      exports: ['default']
    - path: 'src/features/dashboard/DashboardPage.tsx'
      provides: 'Dashboard route component'
      exports: ['default']
    - path: 'src/features/project/ProjectPage.tsx'
      provides: 'Project detail page with transcription flow'
      contains: 'useTranscription'
      exports: ['default']
    - path: 'src/features/settings/SettingsPage.tsx'
      provides: 'Settings route component'
      exports: ['default']
  key_links:
    - from: 'src/app/App.tsx'
      to: 'src/app/Layout.tsx'
      via: 'Route element'
      pattern: 'element=.*Layout'
    - from: 'src/app/App.tsx'
      to: 'src/features/dashboard/DashboardPage.tsx'
      via: 'Route index element'
      pattern: 'index.*element=.*DashboardPage'
    - from: 'src/features/project/ProjectPage.tsx'
      to: 'src/features/project/hooks/useTranscription.ts'
      via: 'hook call'
      pattern: 'useTranscription'
    - from: 'src/features/project/ProjectPage.tsx'
      to: 'src/contexts/SettingsContext.tsx'
      via: 'useSettings hook'
      pattern: 'useSettings'
    - from: 'src/features/dashboard/DashboardPage.tsx'
      to: 'src/contexts/ProjectsContext.tsx'
      via: 'useProjects hook'
      pattern: 'useProjects'
---

<objective>
Decompose the monolithic App.tsx into a router-based architecture with Layout, three page components (Dashboard, Project, Settings), and replace all prop drilling with Context consumption.

Purpose: Satisfies ARCH-02 (React Router navigation) and completes ARCH-01 (module decomposition). This is the final assembly step where all extracted modules (contexts from Plan 01, hooks and services from Plan 02) are composed into the routed page structure. After this plan, App.tsx is a slim routing configuration and all feature logic lives in its respective feature module.

Output: Fully routed application with dashboard, project detail, and settings pages. Zero prop drilling. Monolithic App.tsx replaced with feature-based composition.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-architecture-refactor/04-RESEARCH.md
@.planning/phases/04-core-architecture-refactor/04-01-SUMMARY.md
@.planning/phases/04-core-architecture-refactor/04-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Layout, page components, and routing structure</name>
  <files>
    src/app/App.tsx
    src/app/Layout.tsx
    src/features/dashboard/DashboardPage.tsx
    src/features/settings/SettingsPage.tsx
    src/features/settings/components/ApiKeyForm.tsx
  </files>
  <action>
    1. **Create `src/app/Layout.tsx`:**
       - Extract the header from the current App.tsx into this component
       - Use `NavLink` from react-router for navigation links (Dashboard, Settings)
       - Use `useNavigate` for programmatic navigation
       - Render `<Outlet />` in the main area for child route content
       - The header should include:
         - App logo/title (Interview Insight) linking to `/`
         - Settings icon/link navigating to `/settings`
       - Do NOT include the "New Transcription" button in the header yet (that's project-specific -- the ProjectPage can have it)
       - Keep the same Tailwind styling as the current header
       - Use `NavLink` with `isActive` for active state styling

    2. **Create `src/features/dashboard/DashboardPage.tsx`:**
       - This is a Phase 5 placeholder. Create a minimal but functional page.
       - Use `useProjects()` from ProjectsContext to get the project list
       - If projects exist, show a simple list with project name, status, date, and a link to `/project/:projectId`
       - If no projects, show an empty state message ("No projects yet") with a button/link to start a new transcription
       - Include a "New Transcription" button that navigates to `/project/new` (or creates a project and navigates)
       - This will be rebuilt in Phase 5 -- keep it simple and functional, not polished
       - Use `useNavigate` for navigation

    3. **Create `src/features/settings/components/ApiKeyForm.tsx`:**
       - Extract the API key form content from the current Settings.tsx modal
       - This is the reusable form component (input, validate, save, clear)
       - It should use `useSettings()` to dispatch KEY_SAVED and KEY_CLEARED actions
       - Keep the same validation logic (validateGeminiApiKey, encryptApiKey, etc.)
       - Remove the modal wrapper (backdrop, close button) -- that stays in the page-level component

    4. **Create `src/features/settings/SettingsPage.tsx`:**
       - A full-page route component wrapping ApiKeyForm
       - Show a "Back to Dashboard" link using `useNavigate` or `<Link to="/">`
       - Include a page title ("Settings")
       - Include the storage report from storageService (`getStorageReport()`)
       - The current modal-based Settings.tsx can be kept alongside for backward compat during transition, but the route is the primary entry point

    5. **Rewrite `src/app/App.tsx`:**
       - Replace the entire monolithic component with a slim router configuration:
         ```tsx
         import { BrowserRouter, Routes, Route } from 'react-router';
         import { SettingsProvider } from '@/contexts/SettingsContext';
         import { ProjectsProvider } from '@/contexts/ProjectsContext';
         import Layout from './Layout';
         import DashboardPage from '@/features/dashboard/DashboardPage';
         import ProjectPage from '@/features/project/ProjectPage';
         import SettingsPage from '@/features/settings/SettingsPage';

         export default function App() {
           return (
             <SettingsProvider>
               <ProjectsProvider>
                 <BrowserRouter>
                   <Routes>
                     <Route element={<Layout />}>
                       <Route index element={<DashboardPage />} />
                       <Route path="project/:projectId" element={<ProjectPage />} />
                       <Route path="settings" element={<SettingsPage />} />
                     </Route>
                   </Routes>
                 </BrowserRouter>
               </ProjectsProvider>
             </SettingsProvider>
           );
         }
         ```
       - This should be ~20-30 lines total. All feature logic is gone -- just routing and providers.
       - Note: SettingsProvider and ProjectsProvider are OUTSIDE BrowserRouter. This is correct because contexts don't need router access, and this ensures they're available everywhere.

    IMPORTANT: Do not break the Netlify SPA redirect. The `_redirects` or `netlify.toml` already has `/* /index.html 200`. BrowserRouter will handle client-side routing. Verify that the `netlify.toml` redirect is in place.

  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `npm run lint` exits 0
    - `wc -l src/app/App.tsx` is under 50 lines
    - `grep "BrowserRouter" src/app/App.tsx` returns a match
    - `grep "Outlet" src/app/Layout.tsx` returns a match
    - `grep "useProjects" src/features/dashboard/DashboardPage.tsx` returns a match
    - `grep "useSettings" src/features/settings/components/ApiKeyForm.tsx` returns a match
    - `ls src/features/settings/SettingsPage.tsx` exists
  </verify>
  <done>
    Layout renders the shared header with navigation and Outlet. DashboardPage shows project list from context. SettingsPage renders as a full route with ApiKeyForm. App.tsx is a slim ~25-line routing configuration with provider wrapping.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ProjectPage and wire the complete transcription flow</name>
  <files>
    src/features/project/ProjectPage.tsx
    src/index.tsx
  </files>
  <action>
    1. **Create `src/features/project/ProjectPage.tsx`:**
       - This replaces the main content area of the old App.tsx
       - Use `useParams()` from react-router to get `:projectId`
       - Use `useTranscription()` hook from `@/features/project/hooks/useTranscription`
       - Use `useSettings()` from `@/contexts/SettingsContext` to check `apiKeyConfigured`
       - Use `useNavigate()` for navigation (e.g., back to dashboard, to settings)
       - Compose the existing components:
         - When `state.status === 'idle'` and no file selected: show `<FileUpload />`
         - When `state.status === 'idle'` and file selected: show file info card with "Generate Transcript" button
         - When `state.status === 'uploading'` or `'processing'`: show `<LoadingState />`
         - When `state.status === 'error'`: show error display with "Try Again" button
         - When `state.status === 'completed'`: show `<TranscriptView />`
       - If API key is not configured, show the prompt to open settings (navigate to `/settings`)
       - Handle the "New Transcription" action by calling `reset()` from useTranscription
       - The component receives `fileData` state locally (useState) since it's page-scoped, not global
       - When `projectId === 'new'`: fresh transcription flow. Otherwise, load existing project data from ProjectsContext.

    2. **Ensure `src/index.tsx` is clean:**
       - Should just be the React 18 createRoot entry point
       - Import and render `<App />` from `@/app/App`
       - Import `@/index.css`
       - Wrapped in `<React.StrictMode>`

    3. **Cleanup old components if still present:**
       - The old `src/features/settings/components/Settings.tsx` (modal version) can remain for now but should not be imported by any active component
       - Verify no component imports the old `Settings` modal directly -- all settings access goes through the `/settings` route or `ApiKeyForm`

    4. **End-to-end wiring verification:**
       - Dashboard (`/`) shows projects and has "New Transcription" link
       - Clicking "New Transcription" navigates to `/project/new`
       - Project page shows FileUpload
       - File selection triggers `handleFileSelected` which stores FileData locally
       - "Generate Transcript" calls `startTranscription(fileData)` on the hook
       - Hook dispatches through state machine: uploading -> processing -> completed
       - TranscriptView renders with download/copy functionality
       - Settings link in header navigates to `/settings`
       - Settings page shows ApiKeyForm
       - Back navigation works from all pages

    5. **Final build verification:**
       - `npm run build` must succeed
       - `npx tsc --noEmit` must pass
       - `npm run lint` must pass

    IMPORTANT: The `netlify.toml` SPA redirect `/* /index.html 200` is critical for React Router. Verify it exists and that `[[redirects]]` with `from = "/*"` and `to = "/index.html"` and `status = 200` is present. Do NOT modify the redirect if it already exists.

    IMPORTANT: Preserve the beforeunload listener from storageService. It runs at module load time when storageService is imported (which happens through ProjectsContext -> storageService chain). Verify this import chain is intact.

  </action>
  <verify>
    - `npm run build` exits 0
    - `npx tsc --noEmit` exits 0
    - `npm run lint` exits 0
    - `grep "useTranscription" src/features/project/ProjectPage.tsx` returns a match
    - `grep "useSettings" src/features/project/ProjectPage.tsx` returns a match
    - `grep "useParams" src/features/project/ProjectPage.tsx` returns a match
    - `wc -l src/app/App.tsx` is under 50 lines
    - `grep "beforeunload" src/services/storageService.ts` still present
    - `grep "BrowserRouter" src/app/App.tsx` present
  </verify>
  <done>
    ProjectPage composes FileUpload, LoadingState, and TranscriptView using the useTranscription hook and context state. The full transcription flow works through the routed page structure. App.tsx is a slim routing configuration. All prop drilling is eliminated in favor of context consumption. The application navigates between dashboard, project detail, and settings routes.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` produces a successful production build
2. `npx tsc --noEmit` passes with zero errors
3. `npm run lint` passes with zero errors
4. App.tsx is under 50 lines (just providers + router)
5. Layout.tsx uses Outlet from react-router
6. Three routes exist: `/` (dashboard), `/project/:projectId` (project), `/settings` (settings)
7. ProjectPage uses useTranscription hook (no inline state management)
8. DashboardPage uses useProjects context (no prop drilling)
9. Settings is accessible as a route, not just a modal
10. beforeunload listener chain is intact (storageService -> ProjectsContext -> App)
</verification>

<success_criteria>

- Monolithic App.tsx is fully decomposed -- under 50 lines, just routing and providers
- React Router provides working navigation between all three pages
- No prop drilling -- all state accessed via useSettings(), useProjects(), useTranscription()
- The transcription flow works end-to-end through the new architecture
- Build, type-check, and lint all pass
  </success_criteria>

<output>
After completion, create `.planning/phases/04-core-architecture-refactor/04-03-SUMMARY.md`
</output>
