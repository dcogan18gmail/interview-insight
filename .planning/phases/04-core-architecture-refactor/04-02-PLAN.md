---
phase: 04-core-architecture-refactor
plan: 02
type: execute
wave: 2
depends_on: ['04-01']
files_modified:
  - src/services/geminiService.ts
  - src/services/docxExport.ts
  - src/features/project/hooks/useTranscription.ts
  - src/features/project/components/FileUpload.tsx
  - src/features/project/components/TranscriptView.tsx
autonomous: true

must_haves:
  truths:
    - 'geminiService functions accept apiKey as explicit parameter instead of reading from localStorage'
    - 'DOCX generation logic lives in a dedicated docxExport service, not inside TranscriptView'
    - 'Download All uses sequential async/await instead of brittle setTimeout (BUG-02 fixed)'
    - 'useTranscription hook encapsulates full transcription state machine with typed transitions'
    - 'ObjectURL is revoked after metadata extraction in FileUpload (BUG-01 fixed)'
    - 'Duration extraction handles 0-duration with durationUnknown flag (BUG-03 fixed)'
  artifacts:
    - path: 'src/services/docxExport.ts'
      provides: 'DOCX generation and file download utilities'
      exports:
        ['generateDocxBlob', 'saveBlob', 'formatTimestamp', 'DocxVariant']
    - path: 'src/features/project/hooks/useTranscription.ts'
      provides: 'Transcription state machine hook'
      exports: ['useTranscription']
      contains: 'TRANSITIONS'
    - path: 'src/services/geminiService.ts'
      provides: 'Gemini API integration with explicit apiKey parameter'
      contains: 'apiKey: string'
  key_links:
    - from: 'src/features/project/hooks/useTranscription.ts'
      to: 'src/services/geminiService.ts'
      via: 'calls uploadFile and generateTranscript with apiKey'
      pattern: 'uploadFile.*apiKey|generateTranscript.*apiKey'
    - from: 'src/features/project/hooks/useTranscription.ts'
      to: 'src/contexts/SettingsContext.tsx'
      via: 'gets decrypted API key for service calls'
      pattern: 'getDecryptedKey|useSettings'
    - from: 'src/features/project/components/TranscriptView.tsx'
      to: 'src/services/docxExport.ts'
      via: 'imports generateDocxBlob and saveBlob'
      pattern: 'import.*docxExport'
---

<objective>
Extract the DOCX export service, refactor geminiService to accept explicit API key parameters, create the useTranscription state machine hook, and fix all three known bugs.

Purpose: Satisfies ARCH-05 (stateless gemini service), ARCH-06 (transcription state machine), ARCH-07 (DOCX export extraction), BUG-01 (ObjectURL leak), BUG-02 (download timing), and BUG-03 (duration extraction). These extracted modules become the building blocks that Plan 03 composes into routed pages.

Output: Three extracted/refactored modules (docxExport service, geminiService with apiKey param, useTranscription hook) and three fixed bugs in FileUpload and TranscriptView.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-architecture-refactor/04-RESEARCH.md
@.planning/phases/04-core-architecture-refactor/04-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Extract docxExport service, refactor geminiService, fix BUG-02</name>
  <files>
    src/services/docxExport.ts
    src/services/geminiService.ts
    src/features/project/components/TranscriptView.tsx
  </files>
  <action>
    1. **Create `src/services/docxExport.ts`** by extracting from TranscriptView.tsx:
       - Export type `DocxVariant = 'english' | 'original' | 'combined'`
       - Export function `formatTimestamp(seconds?: number): string` -- moved from TranscriptView
       - Export async function `generateDocxBlob(transcript: TranscriptSegment[], variant: DocxVariant): Promise<Blob>` -- moved from TranscriptView's `generateDocxBlob`, but now accepts `transcript` as parameter (not closure variable)
       - Export function `saveBlob(blob: Blob, filename: string): void` -- moved from TranscriptView
       - Import `Document, Packer, Paragraph, TextRun, HeadingLevel, AlignmentType` from `docx`
       - Import `TranscriptSegment` from `@/types`

    2. **Update `src/features/project/components/TranscriptView.tsx`:**
       - Remove `generateDocxBlob`, `saveBlob`, and `formatTime` function definitions
       - Import `{ generateDocxBlob, saveBlob, formatTimestamp, type DocxVariant }` from `@/services/docxExport`
       - Remove the `docx` library imports (Document, Packer, etc.)
       - Replace `formatTime` calls with `formatTimestamp`
       - **Fix BUG-02 (download timing):** Replace the `handleDownload` function's `'all'` case. Remove the brittle `setTimeout` pattern. Use sequential async/await with a small delay between downloads:
         ```typescript
         if (type === 'all') {
           const types: Array<{ variant: DocxVariant; filename: string }> = [
             { variant: 'english', filename: 'transcript_english.docx' },
             { variant: 'original', filename: 'transcript_original.docx' },
             { variant: 'combined', filename: 'transcript_combined.docx' },
           ];
           for (const { variant, filename } of types) {
             const blob = await generateDocxBlob(transcript, variant);
             saveBlob(blob, filename);
             await new Promise((resolve) => setTimeout(resolve, 100));
           }
         }
         ```
       - For single downloads, update to pass `transcript` as first arg: `generateDocxBlob(transcript, type)`

    3. **Refactor `src/services/geminiService.ts` (ARCH-05):**
       - Remove the `createAI` helper function entirely
       - Remove the import of `getDecryptedKey` from cryptoService
       - **`uploadFile` signature change:** Add `apiKey: string` as the first parameter:
         ```typescript
         export const uploadFile = async (
           apiKey: string,
           file: File,
           onUploadProgress: (progress: number) => void
         ): Promise<string>
         ```
         Remove the internal `getDecryptedKey()` call. Use the passed `apiKey` directly for the `X-Gemini-Key` header.
       - **`generateTranscript` signature change:** Add `apiKey: string` as the first parameter:
         ```typescript
         export const generateTranscript = async (
           apiKey: string,
           fileUri: string,
           mimeType: string,
           durationSeconds: number,
           onProgress: (...) => void
         ): Promise<TranscriptSegment[]>
         ```
         Replace `await createAI()` with `const aiClient = new GoogleGenAI({ apiKey })` directly.

    The service is now pure: no hidden dependencies on localStorage or cryptoService. Callers (useTranscription hook in Task 2) will be responsible for providing the API key.

  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `npm run lint` exits 0
    - `grep -r "setTimeout.*saveBlob" src/` returns NO matches (BUG-02 fixed)
    - `grep -r "getDecryptedKey" src/services/geminiService.ts` returns NO matches (ARCH-05)
    - `grep "apiKey: string" src/services/geminiService.ts` returns matches for both functions
    - `ls src/services/docxExport.ts` exists
  </verify>
  <done>
    docxExport.ts is a standalone service with generateDocxBlob, saveBlob, and formatTimestamp exports. geminiService.ts accepts apiKey as explicit parameter with no hidden localStorage dependency. TranscriptView uses the extracted service and downloads files sequentially without setTimeout race conditions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create useTranscription hook with state machine, fix BUG-01 and BUG-03</name>
  <files>
    src/features/project/hooks/useTranscription.ts
    src/features/project/components/FileUpload.tsx
  </files>
  <action>
    1. **Create `src/features/project/hooks/useTranscription.ts`:**
       - Define transcription state types:
         ```typescript
         type TranscriptionState = 'idle' | 'uploading' | 'processing' | 'completed' | 'error';

         type TranscriptionEvent =
           | { type: 'START_UPLOAD' }
           | { type: 'UPLOAD_COMPLETE'; fileUri: string }
           | { type: 'UPLOAD_ERROR'; error: string }
           | { type: 'PROCESSING_COMPLETE'; segments: TranscriptSegment[] }
           | { type: 'PROCESSING_ERROR'; error: string }
           | { type: 'RESET' };

         interface TranscriptionMachineState {
           status: TranscriptionState;
           fileUri: string | null;
           segments: TranscriptSegment[];
           error: string | null;
           progress: number;
           currentSegment: TranscriptSegment | null;
         }
         ```
       - Define `TRANSITIONS` map (see 04-RESEARCH.md Pattern 3 for the exact structure):
         ```typescript
         const TRANSITIONS: Record<TranscriptionState, Partial<Record<TranscriptionEvent['type'], TranscriptionState>>> = {
           idle: { START_UPLOAD: 'uploading' },
           uploading: { UPLOAD_COMPLETE: 'processing', UPLOAD_ERROR: 'error', RESET: 'idle' },
           processing: { PROCESSING_COMPLETE: 'completed', PROCESSING_ERROR: 'error', RESET: 'idle' },
           completed: { RESET: 'idle' },
           error: { RESET: 'idle', START_UPLOAD: 'uploading' },
         };
         ```
       - Implement `transcriptionReducer` that looks up `TRANSITIONS[state.status][event.type]` and returns the appropriate new state with data from the event payload. Invalid transitions return current state unchanged.
       - Implement `useTranscription` hook:
         ```typescript
         export function useTranscription() {
           const [state, dispatch] = useReducer(transcriptionReducer, INITIAL_STATE);

           const startTranscription = useCallback(async (fileData: FileData) => {
             dispatch({ type: 'START_UPLOAD' });
             try {
               const apiKey = await getDecryptedKey();
               if (!apiKey) throw new Error('No API key configured.');

               let fileUri = fileData.fileUri;
               if (!fileUri && fileData.file) {
                 fileUri = await uploadFile(apiKey, fileData.file, (pct) => {
                   // Update progress during upload -- dispatch a progress event
                   // or use a ref to update progress without triggering full re-render
                 });
               }
               if (!fileUri) throw new Error('Failed to get file URI.');

               dispatch({ type: 'UPLOAD_COMPLETE', fileUri });

               const segments = await generateTranscript(apiKey, fileUri, fileData.type, fileData.duration, (pct, segment) => {
                 // Progress callback -- may use state setter or ref
               });

               dispatch({ type: 'PROCESSING_COMPLETE', segments });
             } catch (error) {
               const message = error instanceof Error ? error.message : 'An error occurred.';
               dispatch({ type: state.status === 'uploading' ? 'UPLOAD_ERROR' : 'PROCESSING_ERROR', error: message });
             }
           }, []);

           const reset = useCallback(() => dispatch({ type: 'RESET' }), []);

           return { state, startTranscription, reset };
         }
         ```
       - For progress updates during the async operation, use `useRef` for progress/currentSegment and periodically sync to state, OR add intermediate dispatch events like `SET_PROGRESS` that don't go through the TRANSITIONS map (a "context event" pattern). Choose whichever keeps the code simpler. The key requirement is that `state.progress` and `state.currentSegment` update during transcription.
       - Import `getDecryptedKey` from `@/services/cryptoService`
       - Import `uploadFile`, `generateTranscript` from `@/services/geminiService`
       - Import types from `@/types`

    2. **Fix BUG-01 (ObjectURL memory leak) in `src/features/project/components/FileUpload.tsx`:**
       In the `processFile` callback, the ObjectURL created by `URL.createObjectURL(file)` is never revoked. Fix:
       - Store the ObjectURL in a variable
       - Create a `cleanup` function that calls `URL.revokeObjectURL(objectUrl)` and `media.remove()`
       - Call `cleanup()` in both `onloadedmetadata` and `onerror` handlers BEFORE calling `onFileSelected`
       - The pattern:
         ```typescript
         const objectUrl = URL.createObjectURL(file);
         const cleanup = () => {
           URL.revokeObjectURL(objectUrl);
           media.remove();
         };
         media.onloadedmetadata = () => {
           const duration = media.duration;
           cleanup();
           // ... rest
         };
         media.onerror = () => {
           cleanup();
           // ... rest
         };
         media.src = objectUrl;
         ```

    3. **Fix BUG-03 (duration extraction) in `src/features/project/components/FileUpload.tsx`:**
       In `processFile`, when duration is 0 or invalid:
       - In `onloadedmetadata`: If `!duration || !isFinite(duration) || duration === 0`, set `durationUnknown: true` on the FileData:
         ```typescript
         if (!duration || !isFinite(duration) || duration === 0) {
           console.warn('[FileUpload] Duration extraction returned 0 or invalid.');
           onFileSelected({ ...data, duration: 0, durationUnknown: true });
         } else {
           onFileSelected({ ...data, duration });
         }
         ```
       - In `onerror`: Always set `durationUnknown: true`:
         ```typescript
         console.warn('[FileUpload] Could not load media metadata for duration extraction.');
         onFileSelected({ name: file.name, type: file.type, size: file.size, file, duration: 0, durationUnknown: true });
         ```

    IMPORTANT: The useTranscription hook is created but NOT wired into the page components yet. Plan 03 will create ProjectPage that uses it. For now, the existing App.tsx logic continues to work (it still has its own useState hooks).

  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `npm run lint` exits 0
    - `ls src/features/project/hooks/useTranscription.ts` exists
    - `grep "TRANSITIONS" src/features/project/hooks/useTranscription.ts` shows the transition map
    - `grep "revokeObjectURL" src/features/project/components/FileUpload.tsx` returns a match (BUG-01)
    - `grep "durationUnknown" src/features/project/components/FileUpload.tsx` returns matches (BUG-03)
    - `grep "apiKey: string" src/services/geminiService.ts` confirms ARCH-05 from Task 1
  </verify>
  <done>
    useTranscription hook encapsulates the full transcription lifecycle (idle -> uploading -> processing -> completed/error) with a typed transition map. FileUpload revokes ObjectURLs on both success and error paths. Duration extraction flags 0-duration with durationUnknown instead of silent failure. The hook calls geminiService with an explicit API key parameter.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` produces a successful production build
2. `npx tsc --noEmit` passes with zero errors
3. `npm run lint` passes with zero errors
4. docxExport.ts exists as a standalone service
5. geminiService.ts has no imports from cryptoService (stateless)
6. useTranscription.ts contains TRANSITIONS map and exports useTranscription
7. FileUpload.tsx calls URL.revokeObjectURL and sets durationUnknown
8. TranscriptView.tsx has no setTimeout in download handler
</verification>

<success_criteria>

- Three extracted/refactored modules compile and pass linting
- All three bugs are fixed with the patterns specified in the research
- geminiService is pure (no hidden localStorage dependency)
- useTranscription hook is ready for consumption by ProjectPage in Plan 03
  </success_criteria>

<output>
After completion, create `.planning/phases/04-core-architecture-refactor/04-02-SUMMARY.md`
</output>
