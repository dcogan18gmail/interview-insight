---
phase: 04-core-architecture-refactor
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - package.json
  - package-lock.json
  - vite.config.ts
  - tsconfig.json
  - index.html
  - tailwind.config.js
  - src/index.tsx
  - src/index.css
  - src/types/index.ts
  - src/services/geminiService.ts
  - src/services/cryptoService.ts
  - src/services/storageService.ts
  - src/services/storageService.types.ts
  - src/contexts/SettingsContext.tsx
  - src/contexts/ProjectsContext.tsx
autonomous: true

must_haves:
  truths:
    - 'All source files live under src/ directory and no .ts/.tsx files remain at project root'
    - 'Dev server starts and renders the existing app without errors after the migration'
    - 'SettingsContext provides API key state and can be consumed via useSettings() hook'
    - 'ProjectsContext provides project CRUD and can be consumed via useProjects() hook'
    - 'TypeScript type-check passes with zero errors after migration'
    - 'ESLint passes after migration'
  artifacts:
    - path: 'src/index.tsx'
      provides: 'App entry point'
    - path: 'src/contexts/SettingsContext.tsx'
      provides: 'API key state management via Context'
      exports: ['SettingsProvider', 'useSettings']
    - path: 'src/contexts/ProjectsContext.tsx'
      provides: 'Project list state management via Context'
      exports: ['ProjectsProvider', 'useProjects']
    - path: 'src/types/index.ts'
      provides: 'Shared type definitions including FileData with durationUnknown flag'
      contains: 'durationUnknown'
    - path: 'vite.config.ts'
      provides: 'Vite config with vite-tsconfig-paths plugin'
      contains: 'tsconfigPaths'
    - path: 'tsconfig.json'
      provides: 'TypeScript config with src/ paths'
      contains: '"./src/*"'
  key_links:
    - from: 'src/contexts/SettingsContext.tsx'
      to: 'src/services/cryptoService.ts'
      via: 'imports hasStoredKey, getDecryptedKey, clearStoredKey'
      pattern: 'import.*cryptoService'
    - from: 'src/contexts/ProjectsContext.tsx'
      to: 'src/services/storageService.ts'
      via: 'imports CRUD functions'
      pattern: 'import.*storageService'
    - from: 'index.html'
      to: 'src/index.tsx'
      via: 'script src'
      pattern: 'src="/src/index.tsx"'
---

<objective>
Migrate the project to a src/ directory structure, install React Router and vite-tsconfig-paths, update all build configs, and create the two Context providers that all subsequent plans depend on.

Purpose: Establishes the foundational directory structure (ARCH-01) and state management layer (ARCH-03, ARCH-04) that all other Phase 4 work builds upon. Without this, no routing, hook extraction, or service refactoring can proceed.

Output: Working app with all source files under src/, two Context providers ready for consumption, and a clean build with no type/lint errors.
</objective>

<execution_context>
@/Users/david.cogan@postman.com/.claude/get-shit-done/workflows/execute-plan.md
@/Users/david.cogan@postman.com/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-core-architecture-refactor/04-RESEARCH.md
@App.tsx
@index.tsx
@index.html
@types.ts
@vite.config.ts
@tsconfig.json
@tailwind.config.js
@services/cryptoService.ts
@services/storageService.ts
@services/storageService.types.ts
@components/FileUpload.tsx
@components/TranscriptView.tsx
@components/LoadingState.tsx
@components/Settings.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Migrate to src/ directory and update all configs</name>
  <files>
    package.json
    package-lock.json
    vite.config.ts
    tsconfig.json
    index.html
    tailwind.config.js
    src/index.tsx
    src/index.css
    src/types/index.ts
    src/app/App.tsx (temporary copy of current App.tsx)
    src/features/project/components/FileUpload.tsx
    src/features/project/components/TranscriptView.tsx
    src/features/project/components/LoadingState.tsx
    src/features/settings/components/Settings.tsx
    src/services/geminiService.ts
    src/services/cryptoService.ts
    src/services/storageService.ts
    src/services/storageService.types.ts
  </files>
  <action>
    1. **Install dependencies:**
       ```bash
       npm install react-router
       npm install -D vite-tsconfig-paths
       ```

    2. **Create the src/ directory structure:**
       ```
       src/
       ├── app/
       ├── features/
       │   ├── dashboard/
       │   ├── project/
       │   │   ├── components/
       │   │   └── hooks/
       │   └── settings/
       │       └── components/
       ├── contexts/
       ├── services/
       └── types/
       ```

    3. **Move source files into src/ (preserve content, fix imports):**
       - `index.tsx` -> `src/index.tsx`
       - `index.css` -> `src/index.css`
       - `App.tsx` -> `src/app/App.tsx` (temporarily -- will be decomposed in Plan 03)
       - `types.ts` -> `src/types/index.ts`
       - `components/FileUpload.tsx` -> `src/features/project/components/FileUpload.tsx`
       - `components/TranscriptView.tsx` -> `src/features/project/components/TranscriptView.tsx`
       - `components/LoadingState.tsx` -> `src/features/project/components/LoadingState.tsx`
       - `components/Settings.tsx` -> `src/features/settings/components/Settings.tsx`
       - `services/geminiService.ts` -> `src/services/geminiService.ts`
       - `services/cryptoService.ts` -> `src/services/cryptoService.ts`
       - `services/storageService.ts` -> `src/services/storageService.ts`
       - `services/storageService.types.ts` -> `src/services/storageService.types.ts`

    4. **Update all import paths in moved files to use `@/` alias:**
       - All `../types` -> `@/types`
       - All `../services/xxxService` -> `@/services/xxxService`
       - All `./components/Xxx` -> `@/features/project/components/Xxx` or similar
       - In `src/app/App.tsx`: update imports to reference new locations
       - In `src/index.tsx`: update `./App` -> `@/app/App`, `./index.css` -> `@/index.css`

    5. **Update types/index.ts:** Add `durationUnknown?: boolean` optional field to the `FileData` interface. This is needed for BUG-03 (handled in Plan 02).

    6. **Update vite.config.ts:**
       ```typescript
       import { defineConfig } from 'vite';
       import react from '@vitejs/plugin-react';
       import tsconfigPaths from 'vite-tsconfig-paths';

       export default defineConfig({
         server: { port: 3000, host: '0.0.0.0' },
         plugins: [react(), tsconfigPaths()],
       });
       ```
       Remove the manual `resolve.alias` and the `path` import.

    7. **Update tsconfig.json:**
       - Change paths from `"./*"` to `"./src/*"`
       - Add `"include": ["src"]`

    8. **Update index.html:** Change script src from `/index.tsx` to `/src/index.tsx`.

    9. **Update tailwind.config.js:** Change content to `['./index.html', './src/**/*.{js,ts,jsx,tsx}']`.

    10. **Delete old root-level source files** (App.tsx, index.tsx, index.css, types.ts) and the old `components/` and `services/` directories after confirming the new files are in place.

    11. **Verify:** Run `npx tsc --noEmit` and `npm run lint` to ensure no errors. Run `npm run build` to verify the production build works.

    IMPORTANT: Do NOT change the `path` import in `eslint.config.mjs` or add anything to it -- ESLint's glob patterns (`**/*.{ts,tsx}`) already work recursively from root.

  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `npm run lint` exits 0
    - `npm run build` exits 0
    - No .ts/.tsx files exist at project root (only in src/)
    - `ls src/app/App.tsx src/index.tsx src/types/index.ts src/services/geminiService.ts` all exist
  </verify>
  <done>
    All source files live under src/. Build toolchain (Vite, TypeScript, ESLint, Tailwind) compiles without errors. The @ alias resolves to src/ in both TypeScript and Vite. FileData type includes optional durationUnknown field.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create SettingsContext and ProjectsContext</name>
  <files>
    src/contexts/SettingsContext.tsx
    src/contexts/ProjectsContext.tsx
    src/app/App.tsx
  </files>
  <action>
    1. **Create `src/contexts/SettingsContext.tsx`** following Kent C. Dodds pattern:
       - State interface: `{ apiKeyConfigured: boolean }`
       - Actions: `KEY_SAVED`, `KEY_CLEARED`
       - Use `useReducer` with a simple reducer
       - `SettingsProvider` component: on mount, check `hasStoredKey()` from cryptoService
       - Export `useSettings()` custom hook with undefined guard (throws if used outside provider)
       - Export `SettingsProvider`
       - Provider value should include `state` and `dispatch`

    2. **Create `src/contexts/ProjectsContext.tsx`** following same pattern:
       - State interface: `{ projects: ProjectMetadata[]; initialized: boolean }`
       - Actions: `PROJECTS_LOADED`, `PROJECT_CREATED`, `PROJECT_UPDATED`, `PROJECT_DELETED`
       - Use `useReducer`
       - `ProjectsProvider` component: on mount, call `initializeStorage()` and `getProjects()` to load initial state, then dispatch `PROJECTS_LOADED`
       - Wrap storageService CRUD functions as context methods:
         - `createProject(name, fileInfo)` -> calls storageService.createProject, dispatches PROJECT_CREATED
         - `updateProject(project)` -> calls storageService.saveProject, dispatches PROJECT_UPDATED
         - `removeProject(id)` -> calls storageService.deleteProject, dispatches PROJECT_DELETED
       - Export `useProjects()` custom hook with undefined guard
       - Export `ProjectsProvider`
       - Import types from `@/services/storageService.types`

    3. **Wire providers into `src/app/App.tsx`:**
       - Wrap existing App content with `<SettingsProvider>` (outermost) then `<ProjectsProvider>` (inner)
       - Verify the app still renders correctly with providers in place
       - The existing App.tsx logic stays intact for now (decomposition happens in Plan 03)

    IMPORTANT: Do NOT remove the existing useState hooks in App.tsx yet. The contexts exist alongside them. Plan 03 will switch the page components to use contexts instead.

    IMPORTANT: Provider ordering matters. SettingsProvider wraps ProjectsProvider because ProjectsContext may later need to know if API key is configured. See Pitfall 4 in research.

  </action>
  <verify>
    - `npx tsc --noEmit` exits 0
    - `npm run lint` exits 0
    - `npm run build` exits 0
    - `grep -r "useSettings" src/contexts/SettingsContext.tsx` shows the hook export
    - `grep -r "useProjects" src/contexts/ProjectsContext.tsx` shows the hook export
    - `grep -r "SettingsProvider" src/app/App.tsx` shows provider wrapping
  </verify>
  <done>
    SettingsContext tracks API key configuration state. ProjectsContext wraps storageService CRUD with React state management. Both providers are wired into the component tree in App.tsx. useSettings() and useProjects() hooks are available for consumption by downstream components.
  </done>
</task>

</tasks>

<verification>
1. `npm run build` produces a successful production build
2. `npx tsc --noEmit` passes with zero errors
3. `npm run lint` passes with zero errors
4. All source files are under src/ -- no .ts/.tsx files at project root
5. Both contexts export providers and custom hooks
6. Providers are nested in App.tsx (SettingsProvider > ProjectsProvider)
</verification>

<success_criteria>

- Project compiles and builds from src/ directory with no errors
- SettingsContext and ProjectsContext are functional and wired into the component tree
- FileData type includes durationUnknown optional field
- The app renders identically to before the migration (no visual or functional regression)
  </success_criteria>

<output>
After completion, create `.planning/phases/04-core-architecture-refactor/04-01-SUMMARY.md`
</output>
